<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Shot: Canvas UI</title>
    <style>
        /* CSSは極限までシンプルに */
        body { 
            margin: 0; padding: 0; overflow: hidden; background-color: #000; 
            touch-action: none; -webkit-user-select: none; user-select: none;
        }
        #game-canvas { 
            display: block; width: 100vw; height: 100dvh; /* dvhでスマホのバー対策 */
            background: #050510;
        }
        /* 読み込み失敗時の保険 */
        #error-msg { color: red; font-size: 20px; display: none; text-align: center; margin-top: 50px; }
    </style>
</head>
<body>

<div id="error-msg">この画面が見えている場合、JavaScriptが動いていません。</div>
<canvas id="game-canvas"></canvas>

<script>
// --- エラー検知 ---
window.onerror = function(msg, url, line) {
    alert("Error: " + msg + "\nLine: " + line);
};

// --- 定数 (ES5) ---
var OPS = {
    add: { label: '＋', color: '#00FF66' },
    sub: { label: '－', color: '#FF8800' },
    mul: { label: '×', color: '#FF00FF' },
    div: { label: '÷', color: '#00FFFF' }
};

// --- ゲーム本体 ---
var game = {
    canvas: null, ctx: null,
    width: 0, height: 0,
    
    // ゲーム状態
    state: 'start', // start, playing, gameover
    score: 0, timeLeft: 90,
    bubbles: [], lasers: [], effects: [],
    mission: { type: 'none', opKey: 'add', target: 0, text: '' },
    
    // UI座標（リサイズ時に計算）
    ui: {
        btnAuto: { x:0, y:0, w:80, h:80 },
        btnFire: { x:0, y:0, w:160, h:80 }
    },
    
    // 内部変数
    lastTime: 0, missionTime: 10, sync: 0, burst: 0,
    
    // --- 初期化 ---
    init: function() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        // リサイズイベント
        window.addEventListener('resize', function() { game.resize(); });
        this.resize();
        
        // タッチイベント (スマホ)
        this.canvas.addEventListener('touchstart', function(e) {
            e.preventDefault(); // スクロール絶対阻止
            for(var i=0; i<e.changedTouches.length; i++) {
                var t = e.changedTouches[i];
                game.handleInput(t.clientX, t.clientY);
            }
        }, {passive: false});

        // マウスイベント (PC)
        this.canvas.addEventListener('mousedown', function(e) {
            game.handleInput(e.clientX, e.clientY);
        });

        // ゲームループ開始
        this.lastTime = Date.now();
        this.loop();
    },

    resize: function() {
        // 画面サイズ取得（安全策）
        var w = document.documentElement.clientWidth;
        var h = document.documentElement.clientHeight;
        
        this.canvas.width = w;
        this.canvas.height = h;
        this.width = w;
        this.height = h;
        
        // ボタン位置の再計算 (画面下部に配置)
        var bottomY = h - 100;
        this.ui.btnAuto = { x: w/2 - 100, y: bottomY, w: 70, h: 70 }; // 左
        this.ui.btnFire = { x: w/2 + 20, y: bottomY, w: 140, h: 70 }; // 右
        
        // バブル配置エリア
        this.cx = w / 2;
        this.cy = h / 2 - 50;
        this.radius = Math.min(w, h - 300) / 2 - 10;
        if(this.radius < 50) this.radius = 50;
    },

    // --- 入力処理 (ボタン判定もここで行う) ---
    handleInput: function(tx, ty) {
        // 1. スタート画面・ゲームオーバー画面のタップ
        if (this.state === 'start' || this.state === 'gameover') {
            this.startGame();
            return;
        }

        // 2. ゲーム中のボタン判定 (座標計算)
        if (this.hitTest(tx, ty, this.ui.btnAuto)) {
            this.autoLock();
            return;
        }
        if (this.hitTest(tx, ty, this.ui.btnFire)) {
            this.fire();
            return;
        }

        // 3. バブルの判定
        for (var i = 0; i < this.bubbles.length; i++) {
            var b = this.bubbles[i];
            // 円形当たり判定
            var dx = tx - b.x;
            var dy = ty - b.y;
            if (dx*dx + dy*dy < (b.r + 15)*(b.r + 15)) {
                this.toggleLock(b);
                return;
            }
        }
    },

    hitTest: function(tx, ty, rect) {
        return (tx >= rect.x && tx <= rect.x + rect.w &&
                ty >= rect.y && ty <= rect.y + rect.h);
    },

    toggleLock: function(b) {
        if (!b.locked) {
            // 計算モードなら3つまで
            var cnt = 0;
            for(var i=0; i<this.bubbles.length; i++) if(this.bubbles[i].locked) cnt++;
            if (this.mission.type === 'calc' && cnt >= 3) return;
            
            b.locked = true;
            b.order = cnt + 1;
        } else {
            b.locked = false;
            b.order = 0;
            // 順番整理
            var locked = [];
            for(var i=0; i<this.bubbles.length; i++) if(this.bubbles[i].locked) locked.push(this.bubbles[i]);
            locked.sort(function(a,b){return a.order - b.order});
            for(var i=0; i<locked.length; i++) locked[i].order = i + 1;
        }
    },

    startGame: function() {
        this.state = 'playing';
        this.score = 0;
        this.timeLeft = 90;
        this.bubbles = [];
        this.sync = 0;
        this.replenish(20);
        this.nextMission();
    },

    // --- ゲームロジック (ES5化) ---
    replenish: function(count) {
        while (this.bubbles.length < count) {
            var isCalc = (this.mission.type === 'calc');
            var type = (isCalc && Math.random() < 0.4) ? 'op' : 'num';
            var val;
            if (type === 'num') val = Math.floor(Math.random() * 25) + 1;
            else {
                var keys = ['add', 'sub', 'mul', 'div'];
                val = keys[Math.floor(Math.random() * 4)];
            }
            this.spawn(val, type);
        }
    },

    spawn: function(val, type) {
        var r = 22;
        var x, y, safe;
        for (var i = 0; i < 20; i++) {
            var ang = Math.random() * 6.28;
            var d = Math.sqrt(Math.random()) * (this.radius - r);
            x = this.cx + Math.cos(ang) * d;
            y = this.cy + Math.sin(ang) * d;
            safe = true;
            for (var k = 0; k < this.bubbles.length; k++) {
                var b = this.bubbles[k];
                var dist = Math.sqrt((b.x-x)*(b.x-x) + (b.y-y)*(b.y-y));
                if (dist < r * 2.2) { safe = false; break; }
            }
            if (safe) break;
        }
        if (!safe) return; // 場所がなければ諦める（次回ループで試行）

        this.bubbles.push({
            x: x, y: y, r: r, val: val, type: type,
            locked: false, order: 0, scale: 0,
            color: (type === 'num' ? '#0074D9' : '#FF4136')
        });
    },

    nextMission: function() {
        var r = Math.random();
        if (r < 0.6) {
            this.mission.type = 'calc';
            this.mission.target = Math.floor(Math.random() * 19) + 2;
            var keys = ['add', 'sub', 'mul', 'div'];
            this.mission.opKey = keys[Math.floor(Math.random() * 4)];
            
            // 確実に解けるように配置
            this.ensureSolvable(this.mission.target, this.mission.opKey);
            this.mission.text = "計算: " + OPS[this.mission.opKey].label + "を使って" + this.mission.target + "を作れ";
        } else {
            this.mission.type = 'mod';
            this.mission.target = (Math.random() < 0.5) ? 0 : 1;
            var label = (this.mission.target === 0 ? "偶数" : "奇数");
            this.mission.text = "指令: " + label + "をすべて撃て";
        }
        this.missionTime = 10;
        
        // ロック解除
        for(var i=0; i<this.bubbles.length; i++) {
            this.bubbles[i].locked = false;
            this.bubbles[i].order = 0;
        }
    },

    ensureSolvable: function(t, op) {
        var n1, n2;
        if(op==='add') { n1=1; n2=t-1; }
        else if(op==='sub') { n1=t+1; n2=1; }
        else if(op==='mul') { n1=1; n2=t; }
        else { n1=t*2; n2=2; }
        
        // 強制追加 (配列の先頭3つを書き換え)
        if(this.bubbles.length < 3) this.replenish(3);
        
        this.bubbles[0].val = n1; this.bubbles[0].type = 'num'; this.bubbles[0].color='#0074D9';
        this.bubbles[1].val = op; this.bubbles[1].type = 'op';  this.bubbles[1].color='#FF4136';
        this.bubbles[2].val = n2; this.bubbles[2].type = 'num'; this.bubbles[2].color='#0074D9';
    },

    calc: function(op, a, b) {
        if(op==='add') return a+b;
        if(op==='sub') return a-b;
        if(op==='mul') return a*b;
        if(op==='div') return (b!==0 && a%b===0) ? a/b : null;
        return null;
    },

    autoLock: function() {
        // 全解除
        for(var i=0; i<this.bubbles.length; i++) {
            this.bubbles[i].locked = false;
            this.bubbles[i].order = 0;
        }

        if (this.mission.type === 'calc') {
            // 正解ペアを探す
            var ops = []; var nums = [];
            for(var i=0; i<this.bubbles.length; i++) {
                var b = this.bubbles[i];
                if(b.type==='op' && b.val===this.mission.opKey) ops.push(b);
                if(b.type==='num') nums.push(b);
            }
            
            var found = false;
            for(var i=0; i<ops.length; i++) {
                for(var j=0; j<nums.length; j++) {
                    for(var k=0; k<nums.length; k++) {
                        if(j===k) continue;
                        if(this.calc(ops[i].val, nums[j].val, nums[k].val) === this.mission.target) {
                            nums[j].locked=true; nums[j].order=1;
                            ops[i].locked=true; ops[i].order=2;
                            nums[k].locked=true; nums[k].order=3;
                            found = true;
                            break;
                        }
                    }
                    if(found) break;
                }
                if(found) break;
            }
            if(found) this.addEffect("LOCKED", this.cx, this.cy, "#00FFFF");
        } else {
            // 偶数奇数
            var rem = this.mission.target;
            var c = 1;
            for(var i=0; i<this.bubbles.length; i++) {
                var b = this.bubbles[i];
                if(b.type==='num' && b.val % 2 === rem) {
                    b.locked = true;
                    b.order = c++;
                }
            }
            if(c>1) this.addEffect("MULTI LOCK", this.cx, this.cy, "#FF00FF");
        }
    },

    fire: function() {
        var locked = [];
        for(var i=0; i<this.bubbles.length; i++) if(this.bubbles[i].locked) locked.push(this.bubbles[i]);
        if(locked.length === 0) return;

        var isHit = false;
        var gain = 0;

        if (this.mission.type === 'calc') {
            var opB = null; var nums = [];
            for(var i=0; i<locked.length; i++) {
                if(locked[i].type==='op') opB = locked[i]; else nums.push(locked[i]);
            }
            if(opB && nums.length===2) {
                var res1 = this.calc(opB.val, nums[0].val, nums[1].val);
                var res2 = this.calc(opB.val, nums[1].val, nums[0].val);
                if(opB.val === this.mission.opKey && (res1===this.mission.target || res2===this.mission.target)) {
                    isHit = true;
                    gain = 1000 + Math.floor(this.missionTime * 100);
                }
            }
        } else {
            var rem = this.mission.target;
            var allOk = true;
            for(var i=0; i<locked.length; i++) {
                if(locked[i].type!=='num' || locked[i].val % 2 !== rem) allOk = false;
            }
            if(allOk && locked.length>0) {
                isHit = true;
                gain = locked.length * 100;
            }
        }

        // レーザー＆削除
        for(var i=0; i<locked.length; i++) {
            var b = locked[i];
            this.lasers.push({ tx: b.x, ty: b.y, color: (isHit?'#00FFFF':'#FF4136'), life:1.0 });
            // 配列から削除
            var idx = this.bubbles.indexOf(b);
            if(idx > -1) this.bubbles.splice(idx, 1);
        }

        if(isHit) {
            this.score += gain;
            this.sync += 25;
            this.addEffect("HIT! +"+gain, this.cx, this.cy-50, "#00FFFF");
            if(this.sync >= 100) { this.state='burst'; this.burst=0; this.sync=0; }
            else { 
                var _this = this;
                setTimeout(function(){ _this.nextMission(); }, 500); 
            }
        } else {
            this.sync = Math.max(0, this.sync - 20);
            this.addEffect("MISS...", this.cx, this.cy-50, "#888");
        }
        
        this.replenish(20);
    },

    addEffect: function(txt, x, y, col) {
        this.effects.push({ text:txt, x:x, y:y, color:col, life:1.0 });
    },

    // --- メインループ ---
    loop: function() {
        var now = Date.now();
        var dt = (now - this.lastTime) / 1000;
        this.lastTime = now;

        if (this.state === 'playing') {
            this.timeLeft -= dt;
            this.missionTime -= dt;
            if (this.missionTime <= 0) this.nextMission();
            if (this.timeLeft <= 0) this.state = 'gameover';
        }

        this.draw();
        requestAnimationFrame(function() { game.loop(); });
    },

    draw: function() {
        var ctx = this.ctx;
        var w = this.width;
        var h = this.height;

        // 背景
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, w, h);

        // バースト演出
        if (this.state === 'burst') {
            this.burst += 10;
            ctx.fillStyle = '#FFF';
            ctx.fillRect(0, 0, w, h);
            if (this.burst > 50) {
                this.state = 'playing';
                this.bubbles = [];
                this.replenish(20);
                this.nextMission();
            }
            return;
        }

        // レーダー
        ctx.strokeStyle = '#003333';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(this.cx, this.cy, this.radius, 0, 6.28); ctx.stroke();

        // バブル
        for (var i = 0; i < this.bubbles.length; i++) {
            var b = this.bubbles[i];
            if(b.scale < 1) b.scale += 0.1;
            var r = b.r * b.scale;
            
            ctx.beginPath(); ctx.arc(b.x, b.y, r, 0, 6.28);
            ctx.fillStyle = b.locked ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.5)';
            ctx.fill();
            ctx.strokeStyle = b.locked ? '#FF00FF' : b.color;
            ctx.lineWidth = b.locked ? 4 : 2;
            ctx.stroke();
            
            // 文字
            ctx.fillStyle = '#FFF'; ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            var txt = (b.type==='num') ? b.val : OPS[b.val].label;
            ctx.fillText(txt, b.x, b.y);
        }

        // UI: ボタン描画 (Canvas内に直接描く！)
        if (this.state === 'playing') {
            // AUTO
            var btnA = this.ui.btnAuto;
            ctx.fillStyle = 'rgba(0,50,50,0.8)';
            ctx.strokeStyle = '#00FFFF'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(btnA.x + btnA.w/2, btnA.y + btnA.h/2, 35, 0, 6.28);
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#00FFFF'; ctx.font = 'bold 12px Arial';
            ctx.fillText("AUTO", btnA.x + btnA.w/2, btnA.y + btnA.h/2 - 5);
            ctx.fillText("LOCK", btnA.x + btnA.w/2, btnA.y + btnA.h/2 + 10);

            // FIRE
            var btnF = this.ui.btnFire;
            // ロック中かどうかで色を変える
            var hasLock = false;
            for(var i=0; i<this.bubbles.length; i++) if(this.bubbles[i].locked) hasLock=true;
            
            ctx.fillStyle = hasLock ? 'rgba(255,65,54,0.9)' : 'rgba(50,0,0,0.5)';
            ctx.strokeStyle = hasLock ? '#FFF' : '#555';
            ctx.beginPath(); ctx.rect(btnF.x, btnF.y, btnF.w, btnF.h);
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = hasLock ? '#FFF' : '#555';
            ctx.font = 'bold 24px Arial';
            ctx.fillText("SHOT", btnF.x + btnF.w/2, btnF.y + btnF.h/2);
        }

        // UI: 情報表示
        if (this.state === 'playing') {
            ctx.fillStyle = '#FFF'; ctx.font = '24px Arial';
            // ミッション
            ctx.textAlign = 'center';
            ctx.fillText(this.mission.text, this.cx, 50);
            
            // スコア・タイム
            ctx.font = '16px Monospace';
            ctx.fillText("SCORE: " + this.score, this.cx - 80, 80);
            ctx.fillText("TIME: " + Math.ceil(this.timeLeft), this.cx + 80, 80);
        }

        // オーバーレイ (スタート/ゲームオーバー)
        if (this.state !== 'playing') {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, w, h);
            
            ctx.fillStyle = '#00FFFF'; ctx.font = 'bold 30px Arial'; ctx.textAlign = 'center';
            if(this.state === 'start') {
                ctx.fillText("BUBBLE SHOT", this.cx, this.cy - 50);
                ctx.fillStyle = '#FFDC00'; ctx.font = 'bold 20px Arial';
                ctx.fillText("TAP SCREEN TO START", this.cx, this.cy + 20);
            } else {
                ctx.fillStyle = '#FF4136';
                ctx.fillText("MISSION OVER", this.cx, this.cy - 50);
                ctx.fillStyle = '#FFF';
                ctx.fillText("SCORE: " + this.score, this.cx, this.cy);
                ctx.fillStyle = '#FFDC00'; ctx.font = 'bold 20px Arial';
                ctx.fillText("TAP TO RETRY", this.cx, this.cy + 50);
            }
        }

        // レーザー
        for(var i=0; i<this.lasers.length; i++) {
            var l = this.lasers[i];
            ctx.strokeStyle = l.color; ctx.lineWidth = 5;
            ctx.beginPath(); ctx.moveTo(this.cx, h); ctx.lineTo(l.tx, l.ty); ctx.stroke();
            l.life -= 0.1;
        }
        // エフェクト
        for(var i=0; i<this.effects.length; i++) {
            var e = this.effects[i];
            ctx.fillStyle = e.color; ctx.font = 'bold 24px Arial';
            ctx.fillText(e.text, e.x, e.y);
            e.y-=1; e.life-=0.02;
        }
    }
};

// 起動
window.onload = function() { game.init(); };
</script>
</body>
</html>
