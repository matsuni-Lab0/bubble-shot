<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Shot - Ebi Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e; /* 深い宇宙/サイバー色 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* スマホでのスクロール防止 */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            text-shadow: 0 0 10px #00d4ff;
            font-size: 24px;
            font-weight: bold;
        }
        .hud-bottom {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            pointer-events: auto;
        }
        /* 必殺技ボタン */
        #auto-lock-btn {
            background: linear-gradient(135deg, #ff00cc, #3333ff);
            border: 2px solid #fff;
            color: white;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 0, 204, 0.6);
            cursor: pointer;
            transition: transform 0.1s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #auto-lock-btn:active {
            transform: scale(0.95);
        }
        #auto-lock-btn:disabled {
            background: #555;
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score">SCORE: 0</div>
            <div id="target">TARGET: ?</div>
        </div>
        <div class="hud-bottom">
            <button id="auto-lock-btn">AUTO LOCK (3)</button>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * Bubble Shot Ver 3.0
 * Developed by Gemmy & Master (with advice from Buzzy)
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const targetEl = document.getElementById('target');
const autoBtn = document.getElementById('auto-lock-btn');

// --- ゲーム設定 ---
const COLS = 6;
const ROWS = 7; // ヘックス配置のため少し多めに
const BUBBLE_RADIUS_RATIO = 0.8; // グリッドに対するバブルの大きさ
let BUBBLE_SIZE = 0;
let OFFSET_X = 0;
let OFFSET_Y = 0;

// --- 状態管理 ---
let score = 0;
let targetNumber = 10;
let autoLockCharges = 3;
let bubbles = []; // 盤面のバブル {x, y, value, type, id, removing}
let selectedBubbles = []; // 選択中のバブル
let particles = []; // エフェクト用
let floatingTexts = []; // 称号テキスト用
let isDragging = false;
let dpr = 1;

// オートロック演出用ステート
let autoLockState = 'idle'; // idle, scanning, locking
let scanTimer = 0;
let scanRadius = 0;

// バブルの種類
const TYPES = ['number', 'operator'];
const OPERATORS = ['+', '-', '×']; // 単純化のため

// --- 初期化処理 ---
function init() {
    resize();
    window.addEventListener('resize', resize);
    
    // 入力イベント
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', (e) => handleStart(e.touches[0]), {passive: false});
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0]); }, {passive: false});
    canvas.addEventListener('touchend', handleEnd);
    
    autoBtn.addEventListener('click', triggerAutoLock);

    resetGame();
    loop();
}

// --- 画面リサイズ（バジィ修正版） ---
function resize() {
    dpr = window.devicePixelRatio || 1;
    // CSSサイズ設定
    const width = window.innerWidth;
    const height = window.innerHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    
    // 実画素数設定
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    
    // ★修正点：累積拡大を防ぐため setTransform を使用
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // グリッド計算
    BUBBLE_SIZE = Math.min(width / (COLS + 1), height / (ROWS + 3));
    OFFSET_X = (width - (BUBBLE_SIZE * COLS)) / 2 + BUBBLE_SIZE / 2;
    OFFSET_Y = (height - (BUBBLE_SIZE * ROWS * 0.9)) / 2 + BUBBLE_SIZE;

    // リサイズ時にバブル位置を再計算
    if(bubbles.length > 0) updateBubblePositions();
}

// --- ゲームロジック ---

function resetGame() {
    score = 0;
    autoLockCharges = 3;
    scoreEl.innerText = `SCORE: ${score}`;
    autoBtn.innerText = `AUTO LOCK (${autoLockCharges})`;
    autoBtn.disabled = false;
    
    // ターゲット設定 (ランダム)
    targetNumber = Math.floor(Math.random() * 10) + 5; // 5~14
    targetEl.innerText = `TARGET: ${targetNumber}`;

    initBoard();
}

// 盤面生成とデッドロックチェック（バジィ修正版）
function initBoard(retry = 0) {
    bubbles = [];
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            // ヘックス配置（奇数行をずらす）
            let cx = c * BUBBLE_SIZE + OFFSET_X;
            if (r % 2 !== 0) cx += BUBBLE_SIZE / 2;
            // 右端のはみ出し防止
            if (r % 2 !== 0 && c === COLS - 1) continue;

            let cy = r * (BUBBLE_SIZE * 0.9) + OFFSET_Y;

            bubbles.push(createRandomBubble(cx, cy, c, r));
        }
    }
    
    // ★修正点：再帰的にチェック（最大2回リトライ）
    if (!checkSolvability() && retry < 2) {
        console.log("Deadlock detected, regenerating... Retry:", retry + 1);
        initBoard(retry + 1);
    }
}

function createRandomBubble(x, y, col, row) {
    const isOp = Math.random() < 0.3; // 30%の確率で演算子
    return {
        id: Math.random().toString(36).substr(2, 9),
        col: col,
        row: row,
        x: x,
        y: y,
        type: isOp ? 'operator' : 'number',
        value: isOp ? OPERATORS[Math.floor(Math.random() * OPERATORS.length)] : Math.floor(Math.random() * 9) + 1,
        color: isOp ? '#ff0055' : '#00aaff',
        scale: 1,
        removing: false
    };
}

function updateBubblePositions() {
    bubbles.forEach(b => {
        let cx = b.col * BUBBLE_SIZE + OFFSET_X;
        if (b.row % 2 !== 0) cx += BUBBLE_SIZE / 2;
        let cy = b.row * (BUBBLE_SIZE * 0.9) + OFFSET_Y;
        b.x = cx;
        b.y = cy;
    });
}

// --- 入力処理 ---
function handleStart(pos) {
    if (autoLockState !== 'idle') return;
    isDragging = true;
    selectedBubbles = [];
    checkHit(pos.clientX, pos.clientY);
}

function handleMove(pos) {
    if (!isDragging) return;
    checkHit(pos.clientX, pos.clientY);
}

function handleEnd() {
    if (!isDragging) return;
    isDragging = false;
    submitSelection();
}

function checkHit(tx, ty) {
    // Canvas座標系への変換は不要（CSSと解像度合わせているため）
    // ただし、タッチ座標はクライアント座標なのでそのままでOK
    
    for (let b of bubbles) {
        if (b.removing) continue;
        const dx = tx - b.x;
        const dy = ty - b.y;
        if (dx * dx + dy * dy < (BUBBLE_SIZE / 2) ** 2) {
            // 選択追加ロジック
            if (selectedBubbles.length === 0) {
                if (b.type === 'number') selectedBubbles.push(b);
            } else {
                const last = selectedBubbles[selectedBubbles.length - 1];
                // 既に選択済みなら戻る処理（Undo）
                if (selectedBubbles.length > 1 && selectedBubbles[selectedBubbles.length - 2] === b) {
                    selectedBubbles.pop();
                    return;
                }
                // 未選択 かつ 隣接している かつ ルール適合
                if (!selectedBubbles.includes(b) && isAdjacent(last, b) && isValidNext(last, b)) {
                    selectedBubbles.push(b);
                    // 演出：バブルが少し跳ねる
                    b.scale = 1.3;
                }
            }
        }
    }
}

// ヘックス隣接判定
function isAdjacent(b1, b2) {
    const dist = Math.sqrt((b1.x - b2.x)**2 + (b1.y - b2.y)**2);
    return dist < BUBBLE_SIZE * 1.2;
}

// 数式ルール判定 (数字 -> 演算子 -> 数字)
function isValidNext(prev, current) {
    if (prev.type === 'number' && current.type === 'operator') return true;
    if (prev.type === 'operator' && current.type === 'number') return true;
    return false;
}

// --- 計算と判定 ---
function submitSelection() {
    if (selectedBubbles.length < 3) {
        selectedBubbles = [];
        return;
    }

    // 末尾が演算子なら無効
    if (selectedBubbles[selectedBubbles.length - 1].type === 'operator') {
        selectedBubbles = [];
        return;
    }

    // 計算
    let expression = "";
    let displayExp = "";
    selectedBubbles.forEach(b => {
        let val = b.value;
        if (val === '×') val = '*';
        expression += val;
        displayExp += b.value;
    });

    try {
        // 安全なeval代替 (簡易)
        const result = new Function('return ' + expression)();
        
        if (result === targetNumber) {
            // 正解！
            handleSuccess(result);
        } else {
            // 不正解演出
            createFloatingText(selectedBubbles[selectedBubbles.length-1].x, selectedBubbles[selectedBubbles.length-1].y, `${result} != ${targetNumber}`, '#ff5555');
        }
    } catch (e) {
        // 計算不能
    }
    
    selectedBubbles = [];
}

function handleSuccess(result) {
    // スコア加算 (長さボーナス)
    const lengthBonus = selectedBubbles.length * 10;
    const addedScore = 100 + lengthBonus;
    score += addedScore;
    scoreEl.innerText = `SCORE: ${score}`;

    // ★演出強化：称号システム
    const lastBubble = selectedBubbles[selectedBubbles.length - 1];
    let title = "GOOD!";
    let color = "#fff";
    
    if (selectedBubbles.length >= 9) { title = "GODLIKE!!"; color = "#ff00ff"; }
    else if (selectedBubbles.length >= 7) { title = "UNBELIEVABLE!"; color = "#00ffff"; }
    else if (selectedBubbles.length >= 5) { title = "EXCELLENT!"; color = "#ffff00"; }
    
    createFloatingText(lastBubble.x, lastBubble.y, title, color, 30);

    // バブル消去 & パーティクル
    selectedBubbles.forEach(b => {
        b.removing = true;
        createParticles(b.x, b.y, b.color);
    });

    // 盤面補充（少し遅延させて降らせる）
    setTimeout(() => {
        fillBoard();
        // ターゲット変更
        targetNumber = Math.floor(Math.random() * 10) + 5;
        targetEl.innerText = `TARGET: ${targetNumber}`;
        
        // 詰みチェック（再生成はしないが、ログに出す）
        if (!checkSolvability()) {
             // 厳密にはここでリシャッフルなどが必要だが、
             // ゲームフローを止めないため今回は「No Moves」表示などの拡張余地とする
             createFloatingText(canvas.width/2/dpr, canvas.height/2/dpr, "NO MOVES? USE AUTO!", "#ff8800");
        }
    }, 300);
}

function fillBoard() {
    // 消えたバブルの列に新しいバブルを補充
    // 今回は簡易的に「消えた場所」に即座に新しいものを生成
    // （本来は上から落ちてくるが、コード量削減のため）
    bubbles = bubbles.map(b => {
        if (b.removing) {
            return createRandomBubble(b.x, b.y, b.col, b.row);
        }
        return b;
    });
}

// --- オートロック（必殺技） ---
function triggerAutoLock() {
    if (autoLockCharges <= 0 || autoLockState !== 'idle') return;
    
    // 経路探索 (DFS)
    const path = findBestPath(targetNumber);
    
    if (path) {
        autoLockCharges--;
        autoBtn.innerText = `AUTO LOCK (${autoLockCharges})`;
        if (autoLockCharges === 0) autoBtn.disabled = true;

        startAutoLockSequence(path);
    } else {
        createFloatingText(canvas.width/2/dpr, canvas.height/2/dpr, "CANNOT LOCK...", "#888");
    }
}

// DFSで解を探す (簡易版：深さ制限あり)
function findBestPath(target) {
    let bestPath = null;
    let maxLength = 0;

    // 全バブル始点で探索
    // ※パフォーマンスのため、全ての数字バブルから探索
    const numbers = bubbles.filter(b => b.type === 'number');
    
    for (let startNode of numbers) {
        // 再帰探索
        dfs(startNode, [startNode]);
    }

    function dfs(current, path) {
        // 枝刈り：長すぎるパスは無視
        if (path.length > 9) return;
        
        // 終了条件：数字で終わっていること
        if (current.type === 'number' && path.length >= 3) {
            let exp = "";
            path.forEach(b => {
                let v = b.value;
                if (v === '×') v = '*';
                exp += v;
            });
            try {
                if (new Function('return ' + exp)() === target) {
                    // 長いパスを優先
                    if (path.length > maxLength) {
                        maxLength = path.length;
                        bestPath = [...path];
                    }
                }
            } catch(e){}
        }

        // 次のステップ
        bubbles.forEach(next => {
            if (!path.includes(next) && isAdjacent(current, next) && isValidNext(current, next)) {
                dfs(next, [...path, next]);
            }
        });
    }

    return bestPath;
}

// 簡易解チェック（初期化時用）
function checkSolvability() {
    return findBestPath(targetNumber) !== null;
}

// ★演出強化：3段階オートロック
function startAutoLockSequence(path) {
    autoLockState = 'scanning';
    scanTimer = 0;
    scanRadius = 0;
    
    // Phase 1: 解析 (0.8秒)
    // レーダーが広がる演出（drawで処理）
    
    setTimeout(() => {
        // Phase 2: ロックオン (0.5秒)
        autoLockState = 'locking';
        // パスを一気に追加するのではなく、順次追加
        let i = 0;
        const interval = setInterval(() => {
            if (i < path.length) {
                selectedBubbles.push(path[i]);
                // 効果音的な演出（振動など）
                path[i].scale = 1.5;
                i++;
            } else {
                clearInterval(interval);
                // Phase 3: 発射
                setTimeout(() => {
                    autoLockState = 'idle';
                    submitSelection();
                }, 300);
            }
        }, 100); // 0.1秒ごとにロック
        
    }, 800);
}


// --- 描画ループ ---
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

function update() {
    // バブルのアニメーション（バウンド）
    bubbles.forEach(b => {
        if (b.scale > 1) b.scale -= 0.05;
        else b.scale = 1;
    });

    // エフェクト更新
    particles.forEach((p, index) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        if (p.life <= 0) particles.splice(index, 1);
    });

    floatingTexts.forEach((t, index) => {
        t.y -= 1;
        t.life -= 0.02;
        if (t.life <= 0) floatingTexts.splice(index, 1);
    });

    // オートロック演出更新
    if (autoLockState === 'scanning') {
        scanRadius += 10;
        if (scanRadius > Math.max(canvas.width, canvas.height)) scanRadius = 0;
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width/dpr, canvas.height/dpr); // Transformしてるので座標系注意

    // 背景グリッド（薄く）
    // ...省略（シンプルにするため）

    // ライン描画
    if (selectedBubbles.length > 1) {
        // ★演出強化：LOCK数に応じた輝き
        const chainLevel = selectedBubbles.length;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // 光彩（Glow）
        ctx.shadowBlur = 10 + chainLevel * 2;
        ctx.shadowColor = '#fff';
        
        // 太さ
        ctx.lineWidth = 5 + chainLevel; 
        ctx.strokeStyle = `hsl(${(Date.now() / 10) % 360}, 100%, 70%)`; // 虹色に光る
        
        ctx.beginPath();
        ctx.moveTo(selectedBubbles[0].x, selectedBubbles[0].y);
        for (let i = 1; i < selectedBubbles.length; i++) {
            ctx.lineTo(selectedBubbles[i].x, selectedBubbles[i].y);
        }
        ctx.stroke();
        
        ctx.shadowBlur = 0; // リセット
    }

    // バブル描画
    bubbles.forEach(b => {
        if (b.removing) return;

        // 選択中は強調
        const isSelected = selectedBubbles.includes(b);
        const size = (BUBBLE_SIZE / 2 * BUBBLE_RADIUS_RATIO) * b.scale;
        
        ctx.beginPath();
        ctx.arc(b.x, b.y, size, 0, Math.PI * 2);
        
        // 色設定（選択中は白っぽく）
        ctx.fillStyle = isSelected ? '#fff' : b.color;
        
        // 影
        ctx.shadowBlur = isSelected ? 20 : 5;
        ctx.shadowColor = b.color;
        
        ctx.fill();
        ctx.shadowBlur = 0;

        // 枠線
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // テキスト
        ctx.fillStyle = isSelected ? b.color : '#fff';
        ctx.font = `bold ${size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(b.value, b.x, b.y + size * 0.1);
    });
    
    // オートロック：スキャン演出
    if (autoLockState === 'scanning') {
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(canvas.width/2/dpr, canvas.height/2/dpr, scanRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        // 解析中の文字
        ctx.fillStyle = '#0f0';
        ctx.font = '20px Courier New';
        ctx.fillText("ANALYZING...", canvas.width/2/dpr, canvas.height/2/dpr + scanRadius + 30);
    }

    // パーティクル
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    });

    // フローティングテキスト
    floatingTexts.forEach(t => {
        ctx.globalAlpha = Math.min(1, t.life);
        ctx.fillStyle = t.color;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.font = `bold ${t.size}px Arial Black`;
        ctx.textAlign = 'center';
        ctx.strokeText(t.text, t.x, t.y);
        ctx.fillText(t.text, t.x, t.y);
        ctx.globalAlpha = 1.0;
    });
}

// --- エフェクト関数 ---
function createParticles(x, y, color) {
    for (let i = 0; i < 10; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1.0,
            color: color,
            size: Math.random() * 5 + 2
        });
    }
}

function createFloatingText(x, y, text, color, size = 20) {
    floatingTexts.push({
        x: x,
        y: y,
        text: text,
        color: color,
        life: 2.0, // 2秒
        size: size
    });
}

// ゲーム開始
init();

</script>
</body>
</html>
