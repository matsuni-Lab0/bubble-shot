<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bubble Shot: Final Fix</title>
    <style>
        /* --- スタイル設定 (スマホ操作・日本語表示最適化) --- */
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: 'Helvetica Neue', Arial, sans-serif; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        #game-container { position: relative; width: 100vw; height: 100dvh; background-color: #050510; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        #top-area { height: 240px; display: flex; flex-direction: column; align-items: center; background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0)); z-index: 10; padding-top: 10px; position: relative; }
        #commander-window { position: absolute; top: 10px; left: 10px; width: 70px; height: 70px; background: rgba(0, 20, 40, 0.6); border: 2px solid #00FFFF; border-radius: 10px; clip-path: polygon(15% 0, 100% 0, 100% 85%, 85% 100%, 0 100%, 0 15%); display: flex; justify-content: center; align-items: center; }
        #comm-canvas { width: 100%; height: 100%; }
        
        #mission-timer-wrapper { width: 200px; height: 4px; background: #222; margin-top: 5px; border-radius: 2px; overflow: hidden; border: 1px solid #444; }
        #mission-timer-bar { width: 100%; height: 100%; background: #FF4136; transition: width 0.1s linear; }
        
        #mission-label { font-size: 10px; color: #00FFFF; letter-spacing: 4px; margin-top: 5px; opacity: 0.8;}
        #mission-method-box { display: flex; align-items: center; gap: 8px; margin-top: 5px; }
        .method-tag { font-size: 10px; color: #888; font-weight: bold; letter-spacing: 1px; }
        
        /* 演算子・条件表示 */
        #mission-op-display { 
            font-size: 28px; font-weight: 900; color: #FF4136; 
            text-shadow: 0 0 10px currentColor; 
            border: 2px solid #FF4136; padding: 0 10px; border-radius: 8px; 
            background: rgba(255, 65, 54, 0.1); 
            min-width: 40px; text-align: center;
            font-family: 'Arial', sans-serif;
        }
        
        /* ターゲット数字表示 */
        #mission-target-display { 
            font-size: 48px; font-weight: 900; color: #FFDC00; line-height: 1.0; 
            text-shadow: 0 0 20px rgba(255, 220, 0, 0.8); 
            font-family: 'Arial Black', sans-serif; 
        }
        
        #mission-sub { font-size: 14px; color: #00FFFF; font-weight: bold; margin-top: 8px; letter-spacing: 1px; }
        
        #status-bar { color: #aaa; font-family: monospace; font-size: 14px; display: flex; gap: 30px; margin-top: 8px; }
        #sync-gauge-container { width: 240px; height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin-top: 10px; border: 1px solid #444; }
        #sync-gauge { width: 0%; height: 100%; background: linear-gradient(90deg, #00FFFF, #FF00FF); transition: width 0.3s; }
        
        /* ボトムエリア（ボタン群） */
        #bottom-area { height: 150px; display: flex; justify-content: center; align-items: center; padding-bottom: 20px; gap: 20px; pointer-events: auto; }
        
        #fire-btn { 
            width: 160px; height: 60px; background: rgba(255, 65, 54, 0.1); border: 2px solid #555; 
            color: #555; font-size: 24px; font-weight: 900; letter-spacing: 4px; 
            display: flex; justify-content: center; align-items: center; 
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); 
            pointer-events: auto; transition: 0.1s; cursor: pointer; 
            -webkit-tap-highlight-color: transparent;
        }
        #fire-btn.ready { background: rgba(255, 65, 54, 0.8); border: none; color: white; box-shadow: 0 0 30px #FF4136; text-shadow: 0 0 10px white; }
        #fire-btn:active { transform: scale(0.95); }
        
        #auto-btn { 
            width: 70px; height: 60px; background: rgba(0, 255, 255, 0.1); 
            border: 2px solid #00FFFF; color: #00FFFF; 
            font-size: 14px; font-weight: bold; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            border-radius: 8px; pointer-events: auto; cursor: pointer; 
            box-shadow: 0 0 10px rgba(0,255,255,0.3); transition: 0.1s; 
            -webkit-tap-highlight-color: transparent;
        }
        #auto-btn:active { transform: scale(0.95); background: #00FFFF; color: #000; }
        #auto-btn span { font-size: 10px; opacity: 0.8; }

        /* オーバーレイ（スタート画面・ゲームオーバー画面） */
        .overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(5, 10, 15, 0.95); 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 100; pointer-events: auto; text-align: center; 
        }
        .hidden { display: none !important; }
        
        /* スタートボタン */
        #start-btn { 
            padding: 15px 50px; font-size: 20px; background: transparent; 
            border: 2px solid #FFDC00; color: #FFDC00; cursor: pointer; 
            font-weight: bold; box-shadow: 0 0 15px #FFDC00; margin-top: 20px;
            -webkit-tap-highlight-color: transparent;
        }
        #start-btn:active { transform: scale(0.95); background: #FFDC00; color: black; }
        
        #retry-btn {
            padding: 15px 50px; font-size: 20px; background: transparent; 
            border: 2px solid #FF4136; color: #FF4136; cursor: pointer; 
            font-weight: bold; box-shadow: 0 0 15px #FF4136; margin-top: 20px;
            -webkit-tap-highlight-color: transparent;
        }
        #retry-btn:active { transform: scale(0.95); background: #FF4136; color: black; }

    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="top-area">
            <div id="commander-window"><canvas id="comm-canvas" width="70" height="70"></canvas></div>
            <div id="mission-label">WEAPON & TARGET</div>
            <div id="mission-timer-wrapper"><div id="mission-timer-bar"></div></div>
            <div id="mission-method-box">
                <span class="method-tag">USE</span>
                <div id="mission-op-display">?</div>
                <span class="method-tag">TO MAKE</span>
                <div id="mission-target-display">0</div>
            </div>
            <div id="mission-sub">指示に従いロックせよ</div>
            <div id="status-bar">
                <span>SCORE: <span id="score">0</span></span>
                <span>TIME: <span id="timer">90</span></span>
            </div>
            <div id="sync-gauge-container"><div id="sync-gauge"></div></div>
        </div>
        <div id="bottom-area">
            <div id="auto-btn">AUTO<span>LOCK</span></div>
            <div id="fire-btn">SHOT</div>
        </div>
    </div>
    
    <div id="menu-screen" class="overlay">
        <h1 style="color: #00FFFF; letter-spacing: 5px;">BUBBLE SHOT</h1>
        <p style="color: #888;">UNDEFINED BLUE PROJECT</p>
        <div id="start-btn">ENGAGE</div>
    </div>
    
    <div id="gameover-screen" class="overlay hidden">
        <h1 style="color: #FF4136;">MISSION OVER</h1>
        <p style="font-size: 28px;">SCORE: <span id="final-score">0</span></p>
        <div id="retry-btn">RE-ENGAGE</div>
    </div>
</div>

<script>
// --- ゲーム定数・設定 ---
const OPS = {
    add: { label: '＋', calc: (a, b) => a + b, color: '#00FF66' },
    sub: { label: '－', calc: (a, b) => a - b, color: '#FF8800' },
    mul: { label: '×', calc: (a, b) => a * b, color: '#FF00FF' },
    div: { label: '÷', calc: (a, b) => (b !== 0 && a % b === 0) ? a / b : null, color: '#00FFFF' }
};

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.commCanvas = document.getElementById('comm-canvas');
        this.commCtx = this.commCanvas.getContext('2d');
        
        this.entities = []; this.effects = []; this.lasers = [];
        this.score = 0; this.timeLeft = 90; this.missionTimeMax = 10.0;
        this.missionTimeLeft = this.missionTimeMax;
        this.syncRatio = 0; this.state = 'menu'; this.lastTime = 0; this.scanAngle = 0;
        this.targetNum = 0; this.targetOp = null; this.burstWave = 0;

        // リサイズ初期化
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // --- ★スマホ対応：イベントリスナーの登録 ---
        // キャンバス操作
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // スクロール防止
            const touch = e.touches[0];
            this.handleInput(touch.clientX, touch.clientY);
        }, { passive: false });

        this.canvas.addEventListener('mousedown', (e) => {
            this.handleInput(e.clientX, e.clientY);
        });

        // ボタン操作（ID指定で登録）
        this.setupButton('start-btn', () => this.start());
        this.setupButton('retry-btn', () => location.reload());
        this.setupButton('fire-btn', () => this.fire());
        this.setupButton('auto-btn', () => this.autoLock());

        this.updateCommander('normal');
        requestAnimationFrame((t) => this.loop(t));
    }

    // ★スマホ対応：ボタン登録ヘルパー
    setupButton(id, callback) {
        const btn = document.getElementById(id);
        if(!btn) return;
        
        // タッチ開始時に実行
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault(); e.stopPropagation();
            callback();
        }, { passive: false });
        
        // マウスダウン時に実行
        btn.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            callback();
        });
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth; this.height = window.innerHeight;
        this.canvas.width = this.width * dpr; this.canvas.height = this.height * dpr;
        this.ctx.scale(dpr, dpr);
        this.centerX = this.width / 2;
        this.centerY = 220 + (this.height - 220 - 150) / 2;
        this.radarRadius = Math.min(this.width, this.height - 420) / 2 - 10;
        this.shipPos = { x: this.width / 2, y: this.height - 50 };
    }

    start() {
        this.state = 'playing'; this.score = 0; this.timeLeft = 90;
        this.entities = []; this.nextMission(); this.replenish();
        document.getElementById('menu-screen').classList.add('hidden');
    }

    // --- ミッション・ゲームロジック ---
    nextMission() {
        const mode = Math.random();
        if(mode < 0.6) {
            // 計算ミッション
            this.isCalcMission = true;
            this.targetNum = Math.floor(Math.random() * 19) + 2;
            const opKeys = Object.keys(OPS);
            this.targetOp = opKeys[Math.floor(Math.random() * opKeys.length)];
            
            document.getElementById('mission-op-display').innerText = OPS[this.targetOp].label;
            document.getElementById('mission-op-display').style.color = OPS[this.targetOp].color;
            document.getElementById('mission-op-display').style.borderColor = OPS[this.targetOp].color;
            document.getElementById('mission-target-display').innerText = this.targetNum;
            document.getElementById('mission-sub').innerText = "計算して数値を作れ";
            
            this.ensureSolutionExists();
        } else {
            // 偶数・奇数ミッション
            this.isCalcMission = false;
            this.targetOp = (Math.random() < 0.5) ? 'even' : 'odd';
            
            const label = (this.targetOp === 'even' ? '偶数' : '奇数');
            document.getElementById('mission-op-display').innerText = label;
            document.getElementById('mission-op-display').style.color = "#FFDC00";
            document.getElementById('mission-op-display').style.borderColor = "#FFDC00";
            document.getElementById('mission-target-display').innerText = "TARGET";
            document.getElementById('mission-target-display').style.fontSize = "32px";
            document.getElementById('mission-sub').innerText = label + "をすべて撃て";
        }
        this.missionTimeLeft = 10.0;
        this.entities.forEach(e => { e.locked = false; e.order = 0; });
        this.updateFireButton();
        this.updateCommander('normal');
    }

    ensureSolutionExists() {
        if(!this.isCalcMission) return;
        let n1, n2;
        const op = this.targetOp;
        const target = this.targetNum;

        if(op === 'add') { n1 = Math.floor(Math.random() * (target - 1)) + 1; n2 = target - n1; }
        else if(op === 'sub') { n2 = Math.floor(Math.random() * 10) + 1; n1 = target + n2; }
        else if(op === 'mul') {
            const divisors = [];
            for(let i=1; i<=target; i++) { if(target % i === 0) divisors.push(i); }
            n1 = divisors[Math.floor(Math.random() * divisors.length)]; n2 = target / n1;
        } else if(op === 'div') { n2 = Math.floor(Math.random() * 5) + 1; n1 = target * n2; }

        this.spawnEntityFixed(n1, 'num', true);
        this.spawnEntityFixed(op, 'op', true);
        this.spawnEntityFixed(n2, 'num', true);
    }

    spawnEntityFixed(val, type, force = false) {
        const r = 22;
        let attempts = 0;
        while(attempts < 200) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.sqrt(Math.random()) * (this.radarRadius - r - 10);
            const x = this.centerX + Math.cos(angle) * dist;
            const y = this.centerY + Math.sin(angle) * dist;
            let safe = true;
            for(let e of this.entities) { if(Math.hypot(e.x - x, e.y - y) < r * 2.6) { safe = false; break; } }
            if(safe) {
                this.entities.push({ x, y, r, val, type, scale: 0, locked: false, alive: true, order: 0 });
                return;
            }
            attempts++;
        }
        if(force) {
            if(this.entities.length > 0) {
                const old = this.entities.shift();
                this.entities.push({ x: old.x, y: old.y, r, val, type, scale: 0, locked: false, alive: true, order: 0 });
            } else {
                this.entities.push({ x: this.centerX, y: this.centerY, r, val, type, scale: 0, locked: false, alive: true, order: 0 });
            }
        }
    }

    replenish() { while (this.entities.length < 20) { this.spawnEntity(); } }

    spawnEntity() {
        const r = 22;
        const type = (this.isCalcMission && Math.random() < 0.4) ? 'op' : 'num';
        let val = type === 'num' ? Math.floor(Math.random() * 25) + 1 : Object.keys(OPS)[Math.floor(Math.random() * 4)];
        this.spawnEntityFixed(val, type, false);
    }

    // --- 入力ハンドリング (共通化) ---
    handleInput(tx, ty) {
        if(this.state !== 'playing') return;
        const rect = this.canvas.getBoundingClientRect();
        const x = tx - rect.left;
        const y = ty - rect.top;

        for(let ent of this.entities) {
            if(Math.hypot(ent.x - x, ent.y - y) < ent.r + 15) {
                if(!ent.locked) {
                    const lockedCount = this.entities.filter(e => e.locked).length;
                    if(this.isCalcMission && lockedCount >= 3) return; // 計算時は3つまで
                    ent.locked = true; ent.order = lockedCount + 1;
                } else {
                    ent.locked = false; ent.order = 0;
                    let count = 1;
                    this.entities.filter(e => e.locked).sort((a,b)=>a.order-b.order).forEach(e => e.order = count++);
                }
                this.updateFireButton(); return;
            }
        }
    }

    autoLock() {
        if(this.state !== 'playing') return;
        this.entities.forEach(e => { e.locked = false; e.order = 0; });

        if (this.isCalcMission) {
            const ops = this.entities.filter(e => e.type === 'op' && e.val === this.targetOp);
            const nums = this.entities.filter(e => e.type === 'num');
            let found = false;
            for (let op of ops) {
                for (let n1 of nums) {
                    for (let n2 of nums) {
                        if (n1 === n2) continue;
                        if (OPS[this.targetOp].calc(n1.val, n2.val) === this.targetNum) {
                            n1.locked = true; n1.order = 1; op.locked = true; op.order = 2; n2.locked = true; n2.order = 3;
                            found = true; break;
                        }
                    }
                    if(found) break;
                }
                if(found) break;
            }
            if(found) this.addEffect("TARGET LOCKED", this.centerX, this.centerY, "#00FFFF", 20);
        } else {
            let count = 1;
            this.entities.forEach(e => {
                if(e.type === 'num') {
                    const isEven = e.val % 2 === 0;
                    if((this.targetOp === 'even' && isEven) || (this.targetOp === 'odd' && !isEven)) {
                        e.locked = true; e.order = count++;
                    }
                }
            });
            if(count > 1) this.addEffect("MULTI LOCK", this.centerX, this.centerY, "#FF00FF", 20);
        }
        this.updateFireButton();
    }

    updateFireButton() {
        const locked = this.entities.filter(e => e.locked);
        const btn = document.getElementById('fire-btn');
        let ready = false;
        if (this.isCalcMission) {
            const opCount = locked.filter(e => e.type === 'op').length;
            const numCount = locked.filter(e => e.type === 'num').length;
            ready = (opCount === 1 && numCount === 2);
        } else {
            ready = locked.length > 0;
        }
        if(ready) btn.classList.add('ready'); else btn.classList.remove('ready');
    }

    fire() {
        if(this.state !== 'playing') return;
        const locked = this.entities.filter(e => e.locked);
        if(locked.length === 0) return;
        let hitAll = true, totalGain = 0;

        if(this.isCalcMission) {
            const opEntity = locked.find(e => e.type === 'op');
            const nums = locked.filter(e => e.type === 'num');

            if (opEntity && nums.length === 2) {
                const n1 = nums[0].val;
                const n2 = nums[1].val;
                const res1 = OPS[opEntity.val].calc(n1, n2);
                const res2 = OPS[opEntity.val].calc(n2, n1);
                
                if ((res1 === this.targetNum || res2 === this.targetNum) && opEntity.val === this.targetOp) {
                    hitAll = true;
                    totalGain = 500 + Math.floor(this.missionTimeLeft * 100);
                } else {
                    hitAll = false;
                }
            } else {
                hitAll = false;
            }
        } else {
            locked.forEach(ent => {
                const isCorrect = (this.targetOp === 'even' ? ent.val % 2 === 0 : ent.val % 2 !== 0);
                if(isCorrect) totalGain += 150; else hitAll = false;
            });
            if(hitAll) totalGain += Math.floor(this.missionTimeLeft * 50);
        }

        locked.forEach(ent => {
            this.lasers.push({ x1: this.shipPos.x, y1: this.shipPos.y, x2: ent.x, y2: ent.y, life: 0.2, color: hitAll ? '#00FFFF' : '#FF4136', ent: ent });
            ent.alive = false;
        });

        if(hitAll) {
            this.score += totalGain; this.syncRatio = Math.min(100, this.syncRatio + (this.isCalcMission ? 20 : locked.length * 5));
            this.addEffect(`HIT! +${totalGain}`, this.centerX, this.centerY - 40, "#00FFFF", 28);
            this.updateCommander('happy');
        } else {
            this.syncRatio = Math.max(0, this.syncRatio - 15); this.updateCommander('panic');
        }
        this.entities = this.entities.filter(e => e.alive); this.replenish(); this.updateFireButton();
        if(this.syncRatio >= 100) this.fullBurst(); else setTimeout(() => this.nextMission(), 400);
    }

    fullBurst() {
        this.state = 'burst'; this.burstWave = 0; this.syncRatio = 0;
        this.updateCommander('fever'); this.effects.push({ type: 'flash', life: 0.6 });
    }

    updateUI() {
        document.getElementById('score').innerText = this.score;
        document.getElementById('timer').innerText = Math.floor(this.timeLeft);
        document.getElementById('sync-gauge').style.width = this.syncRatio + '%';
        document.getElementById('mission-timer-bar').style.width = (this.missionTimeLeft / 10 * 100) + '%';
    }

    loop(t) {
        const dt = (t - this.lastTime) / 1000; this.lastTime = t;
        if(this.state === 'playing') {
            this.timeLeft -= dt; this.missionTimeLeft -= dt;
            if(this.missionTimeLeft <= 0) this.nextMission();
            if(this.timeLeft <= 0) {
                this.state = 'gameover';
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('final-score').innerText = this.score;
            }
            this.updateUI();
        } else if (this.state === 'burst') {
            this.burstWave += dt * 2000;
            if(this.burstWave > this.width * 1.5) { this.state = 'playing'; this.entities = []; this.replenish(); this.nextMission(); }
        }
        this.scanAngle += dt * 2; this.draw();
        requestAnimationFrame((t) => this.loop(t));
    }

    draw() {
        const ctx = this.ctx; ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, this.width, this.height);
        ctx.save(); ctx.translate(this.centerX, this.centerY);
        ctx.strokeStyle = '#00FFFF'; ctx.lineWidth = 5; ctx.shadowBlur = 15; ctx.shadowColor = '#00FFFF';
        ctx.beginPath(); ctx.arc(0,0,this.radarRadius,0,Math.PI*2); ctx.stroke(); ctx.shadowBlur = 0;
        ctx.restore();
        this.lasers = this.lasers.filter(l => {
            ctx.strokeStyle = l.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
            l.life -= 0.02; return l.life > 0;
        });
        if(this.state === 'burst') {
            ctx.strokeStyle = 'magenta'; ctx.lineWidth = 15;
            ctx.beginPath(); ctx.arc(this.shipPos.x, this.shipPos.y, this.burstWave, 0, Math.PI*2); ctx.stroke();
        }
        this.entities.forEach(ent => {
            if(ent.scale < 1) ent.scale += 0.1;
            const s = ent.r * ent.scale;
            ctx.beginPath(); ctx.arc(ent.x, ent.y, s, 0, Math.PI*2);
            ctx.fillStyle = ent.locked ? 'rgba(255, 0, 255, 0.2)' : (ent.type === 'op' ? 'rgba(0, 255, 100, 0.05)' : 'rgba(0, 255, 255, 0.05)');
            ctx.fill(); ctx.strokeStyle = ent.locked ? '#FF00FF' : (ent.type === 'op' ? OPS[ent.val].color : '#00FFFF');
            ctx.lineWidth = ent.locked ? 3 : 1; ctx.stroke();
            if(ent.locked) this.drawLockBracket(ent.x, ent.y, s + 8, ent.order);
            ctx.fillStyle = ent.locked ? '#FF00FF' : 'white';
            ctx.font = 'bold 18px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const displayVal = ent.type === 'op' ? OPS[ent.val].label : ent.val;
            ctx.fillText(displayVal, ent.x, ent.y);
        });
        this.effects = this.effects.filter(eff => {
            ctx.globalAlpha = eff.life;
            if(eff.type === 'flash') { ctx.fillStyle = `rgba(255,255,255,${eff.life})`; ctx.fillRect(0,0,this.width,this.height); }
            else { ctx.fillStyle = eff.color; ctx.font = `bold ${eff.size}px Arial`; ctx.fillText(eff.text, eff.x, eff.y); eff.y -= 1; }
            eff.life -= 0.02; return eff.life > 0;
        });
        ctx.globalAlpha = 1;
    }

    drawLockBracket(x, y, r, order) {
        const ctx = this.ctx; ctx.strokeStyle = '#FF00FF'; ctx.lineWidth = 2; const len = 10;
        ctx.beginPath(); ctx.moveTo(x-r, y-r+len); ctx.lineTo(x-r, y-r); ctx.lineTo(x-r+len, y-r); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x+r-len, y-r); ctx.lineTo(x+r, y-r); ctx.lineTo(x+r, y-r+len); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x-r, y+r-len); ctx.lineTo(x-r, y+r); ctx.lineTo(x-r+len, y+r); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x+r-len, y+r); ctx.lineTo(x+r, y+r); ctx.lineTo(x+r, y+r-len); ctx.stroke();
    }

    updateCommander(mood) { this.commCtx.clearRect(0,0,70,70); this.drawEbiFace(this.commCtx, 35, 35, 25, mood); }
    drawEbiFace(ctx, x, y, size, mood) {
        ctx.fillStyle = mood === 'fever' ? '#FF4136' : (mood === 'panic' ? '#A0A0FF' : '#FFDB58');
        ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.ellipse(x-size*0.4, y-size*0.5, size*0.2, size*0.1, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(x+size*0.3, y-size*0.4, size*0.25, size*0.15, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(x-size*0.3, y+size*0.1, size*0.1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x+size*0.3, y+size*0.1, size*0.1, 0, Math.PI*2); ctx.fill();
        if(mood==='happy'||mood==='fever') { ctx.beginPath(); ctx.arc(x, y+size*0.1, size*0.3, 0, Math.PI); ctx.stroke(); }
        else { ctx.beginPath(); ctx.arc(x, y+size*0.2, size*0.3, 0.2*Math.PI, 0.8*Math.PI); ctx.stroke(); }
    }
    addEffect(text, x, y, color, size) { this.effects.push({ text, x, y, color, size, life: 1 }); }
}
window.game = new Game();
</script>
</body>
</html>
