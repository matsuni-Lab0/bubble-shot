<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bubble Shot: Baker's Edition</title>
    <style>
        /* --- CSS設定 --- */
        body {
            margin: 0; overflow: hidden; background-color: #111; color: white;
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            touch-action: none; user-select: none; -webkit-user-select: none;
        }
        #game-container {
            position: relative; width: 100vw; height: 100dvh; overflow: hidden;
            background-color: #050510;
            background-image: 
                linear-gradient(rgba(255, 165, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 165, 0, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }

        /* --- 上部エリア --- */
        #top-area {
            height: 180px; display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start; background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0));
            z-index: 10; padding-top: 10px; box-sizing: border-box; position: relative;
        }

        .circle-btn {
            position: absolute; top: 15px; width: 45px; height: 45px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center; pointer-events: auto;
            cursor: pointer; z-index: 20; font-weight: bold; font-size: 20px;
            transition: transform 0.1s; backdrop-filter: blur(4px);
        }
        .circle-btn:active { transform: scale(0.9); }

        #manual-shuffle-btn {
            left: 15px; background: rgba(255, 165, 0, 0.1); border: 2px solid #FFA500;
            color: #FFA500; box-shadow: 0 0 10px rgba(255, 165, 0, 0.2); font-size: 18px;
        }

        /* オートロックボタン */
        #auto-lock-btn {
            position: absolute; bottom: 100px; right: 20px;
            width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255, 215, 0, 0.2); border: 2px solid #FFD700; color: #FFD700;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 10px; font-weight: 900; text-align: center;
            box-shadow: 0 0 15px #FFD700; cursor: pointer; pointer-events: auto; z-index: 30;
            animation: pulse 2s infinite; line-height: 1.1;
        }
        .ja-sub { font-size: 8px; font-weight: normal; opacity: 0.8; }
        .trial-badge { 
            position: absolute; top: -5px; right: -5px; background: #FF4136; color: #fff;
            font-size: 8px; padding: 2px 4px; border-radius: 4px; font-weight: bold;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }

        #time-bar-wrapper {
            width: 60%; height: 8px; background: #222; border-radius: 4px;
            margin-bottom: 8px; border: 1px solid #555; position: relative; overflow: hidden;
        }
        #time-bar { width: 100%; height: 100%; background: #0074D9; transition: width 0.1s linear, background 0.3s; box-shadow: 0 0 10px currentColor; }
        
        #target-label { font-size: 10px; color: #00FFFF; letter-spacing: 4px; margin-top: 5px; opacity: 0.8;}
        #target-display {
            font-size: 64px; font-weight: 900; color: #FFDC00; line-height: 1.0; margin: 0;
            text-shadow: 0 0 20px rgba(255, 220, 0, 0.8); font-family: 'Arial Black', sans-serif; letter-spacing: -2px;
        }
        #status-bar {
            color: #aaa; font-family: monospace; font-size: 16px; display: flex; gap: 20px;
            font-weight: bold; margin-top: 5px; text-shadow: 0 0 2px #000;
        }
        #fever-label { font-size: 10px; color: #888; margin-top: 5px; letter-spacing: 2px;}
        #fever-gauge-container { width: 200px; height: 4px; background: #333; border-radius: 2px; overflow: hidden; margin-top: 2px; }
        #fever-gauge { width: 0%; height: 100%; background: linear-gradient(90deg, #FFDC00, #FF4136); transition: width 0.3s; box-shadow: 0 0 5px #FF4136; }

        /* --- 下部エリア --- */
        #bottom-area {
            height: 180px; display: flex; flex-direction: column; align-items: center;
            justify-content: flex-end; padding-bottom: 30px;
            background: linear-gradient(to top, rgba(0,20,30,0.95) 60%, rgba(0,0,0,0)); z-index: 10;
        }
        #guide-msg {
            color: #00FFFF; font-size: 14px; margin-bottom: 5px; min-height: 35px;
            text-shadow: 0 0 5px #00FFFF; letter-spacing: 1px; text-align: center; line-height: 1.3;
        }
        #guide-msg .sub { font-size: 10px; color: #aaa; display: block; margin-top: 2px;}
        #formula-bar {
            min-height: 30px; margin-bottom: 15px; font-size: 24px; color: #FFF; font-family: monospace;
            font-weight: bold; text-shadow: 0 0 5px #00FFFF, 0 0 10px #00FFFF; white-space: nowrap;
            max-width: 90%; overflow: hidden; text-overflow: ellipsis;
        }
        #btn-group { display: flex; gap: 20px; align-items: center; }
        #fire-btn {
            width: 150px; height: 60px; background: rgba(255, 65, 54, 0.1); border: 2px solid #555;
            color: #555; font-size: 24px; font-weight: 900; letter-spacing: 4px; display: flex;
            justify-content: center; align-items: center; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            transition: all 0.2s; cursor: pointer; pointer-events: none;
        }
        #fire-btn.ready {
            background: rgba(255, 65, 54, 0.8); border: none; color: white; box-shadow: 0 0 30px #FF4136;
            pointer-events: auto; transform: scale(1.05); text-shadow: 0 0 10px white;
        }
        #fire-btn:active { transform: scale(0.95); background: #fff; color: #FF4136; }
        #clear-btn {
            width: 50px; height: 50px; border-radius: 50%; border: 1px solid #00FFFF; color: #00FFFF;
            display: flex; justify-content: center; align-items: center; font-size: 10px; cursor: pointer;
            background: rgba(0, 255, 255, 0.05); pointer-events: auto; box-shadow: 0 0 5px rgba(0, 255, 255, 0.2);
        }

        /* --- 画面オーバーレイ --- */
        #menu-screen, #gameover-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 10, 15, 0.95); display: flex; flex-direction: column;
            justify-content: flex-start; align-items: center; pointer-events: auto; z-index: 50;
            text-align: center; box-sizing: border-box; padding: 40px 20px; overflow-y: auto;
        }
        #menu-screen { justify-content: center; }

        h1 { 
            color: #00FFFF; font-size: 36px; font-weight: 900; text-shadow: 0 0 10px #00FFFF, 0 0 30px #00FFFF; 
            margin: 10px 0; letter-spacing: 4px; font-style: italic; font-family: 'Arial Black', sans-serif;
        }
        
        .btn {
            padding: 15px 40px; font-size: 18px; background: transparent; border: 2px solid #FFDC00;
            color: #FFDC00; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px #FFDC00, inset 0 0 10px #FFDC00;
            transition: all 0.2s; margin-top: 15px; text-transform: uppercase; letter-spacing: 2px;
            width: 100%; max-width: 300px;
        }
        .btn:hover { background: #FFDC00; color: #000; box-shadow: 0 0 30px #FFDC00; }

        /* 誘導ボタン用スタイル */
        .btn-link {
            border-color: #2ECC40; color: #2ECC40; box-shadow: 0 0 10px #2ECC40, inset 0 0 10px #2ECC40;
            font-size: 14px; padding: 12px 20px;
        }
        .btn-link:hover { background: #2ECC40; color: #000; box-shadow: 0 0 30px #2ECC40; }
        .btn-roblox {
            border-color: #AAAAAA; color: #AAAAAA; box-shadow: none; border-style: dashed;
        }

        .rule-box {
            font-size: 14px; color: #ccc; line-height: 1.6; margin-bottom: 20px; text-align: left; display: inline-block;
        }
        .rule-box .en { color: #fff; font-weight: bold; display: block; margin-bottom: 2px;}
        .rule-box .ja { color: #888; font-size: 11px; display: block; margin-bottom: 10px;}
        
        #rank-list-container {
            width: 100%; max-width: 350px; margin-bottom: 20px; text-align: left; border-top: 1px solid #333; margin-top: 20px;
        }
        .rank-item {
            display: flex; justify-content: space-between; align-items: center; padding: 8px 5px; border-bottom: 1px solid #222; font-family: monospace;
        }
        .rank-item.active {
            color: #FFDC00; background: linear-gradient(90deg, transparent, rgba(255, 220, 0, 0.1), transparent);
            font-weight: bold; text-shadow: 0 0 5px #FFDC00;
        }
        .rank-name-col { flex-grow: 1; padding-left: 10px; display: flex; flex-direction: column;}
        .rank-name-en { font-size: 14px; color: #ccc; }
        .rank-name-ja { font-size: 10px; color: #666; }
        .active .rank-name-en { color: #FFDC00; }
        .active .rank-name-ja { color: #AA8800; }
        .rank-score { width: 60px; text-align: right; font-size: 14px; color: #888; }
        .rank-arrow { width: 40px; color: #FF4136; text-align: right; font-weight:bold; font-size: 12px; animation: blink 0.5s infinite alternate; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="top-area">
            <div id="manual-shuffle-btn" class="circle-btn" onclick="game.manualShuffle()">↻</div>
            <div id="time-bar-wrapper"><div id="time-bar"></div></div>
            <div id="target-label">TARGET</div>
            <div id="target-display">??</div>
            <div id="status-bar">
                <span id="score-display">SCORE: 0</span>
                <span id="timer-display">TIME: 90</span>
            </div>
            <div id="fever-label">SYNC RATIO</div>
            <div id="fever-gauge-container"><div id="fever-gauge"></div></div>
        </div>
        
        <div style="flex-grow: 1;"></div>
        
        <div id="auto-lock-btn" onclick="game.autoLock()">
            <div class="trial-badge">FREE TRIAL</div>
            AUTO<br>LOCK
            <span class="ja-sub">自動(お試し)</span>
        </div>

        <div id="bottom-area">
            <div id="guide-msg">
                LOCK: [NUM]
                <span class="sub">数字をロックせよ</span>
            </div>
            <div id="formula-bar">READY...</div>
            <div id="btn-group">
                <div id="clear-btn" onclick="game.clearFormula()">CLR</div>
                <div id="fire-btn" onclick="game.fire()">FIRE</div>
            </div>
        </div>
    </div>

    <div id="menu-screen">
        <h1>BUBBLE SHOT</h1>
        <p style="color:#00FFFF; font-size:12px; margin-bottom: 20px; font-family: monospace;">
            SYSTEM: ONLINE<br>MODE: FULL YEAST BURST
        </p>
        
        <div class="rule-box">
            <span class="en">1. Lock numbers to match the TARGET.</span>
            <span class="ja">ターゲットと同じ数字になるようロックオン。</span>
            <span class="en">2. Use SYMBOLS (+ - × ÷) between numbers.</span>
            <span class="ja">数字と数字の間に記号（＋－×÷）を挟む。</span>
            <span class="en">3. "AUTO LOCK" solves it instantly!</span>
            <span class="ja">困ったら「AUTO LOCK」で一撃必殺！(2D版無料)</span>
        </div>

        <button class="btn" onclick="game.start()">BAKE START</button>
        
        <div style="margin-top: 30px; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px;">
            <button class="btn btn-link" onclick="openLink('line')">
                LINE STICKERS<br><span style="font-size:10px">LINEスタンプを見る</span>
            </button>
            <button class="btn btn-roblox" onclick="openLink('roblox')">
                COMING SOON to ROBLOX<br><span style="font-size:10px">3D版 ロブロックスで準備中</span>
            </button>
        </div>
    </div>

    <div id="gameover-screen" class="hidden">
        <h1 id="result-title">MISSION OVER</h1>
        <p id="result-final">0</p>
        
        <div id="rank-list-container"></div>

        <button class="btn" onclick="location.reload()">RE-BAKE</button>
        
        <div style="margin-top: 20px; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px;">
            <button class="btn btn-link" onclick="openLink('line')">
                Check Characters?<br><span style="font-size:10px">キャラが気になったらスタンプへ</span>
            </button>
        </div>
    </div>
</div>

<script>
// ★★★ URL設定エリア ★★★
const URL_CONFIG = {
    line: "",    
    roblox: ""   
};

function openLink(type) {
    const url = URL_CONFIG[type];
    if (url && url.length > 0) {
        window.open(url, '_blank');
    } else {
        alert("Coming Soon! \n準備中です。公開をお楽しみに！");
    }
}

const OPS = {
    add: { label: '+', op: '+' },
    sub: { label: '-', op: '-' },
    mul: { label: '×', op: '*' },
    div: { label: '÷', op: '/' }
};

const FEVER_TYPES = [
    { id: 'asc', labelEn: 'ASCENDING (Low->High)', labelJa: '昇順で撃て (小 → 大)' },
    { id: 'desc', labelEn: 'DESCENDING (High->Low)', labelJa: '降順で撃て (大 → 小)' },
    { id: 'even', labelEn: 'EVEN NUMBERS', labelJa: '偶数を撃て' },
    { id: 'odd', labelEn: 'ODD NUMBERS', labelJa: '奇数を撃て' }
];

const RANKS = [
    { min: 30000, nameEn: "DIVINE BAKER",   nameJa: "パンの神" },
    { min: 20000, nameEn: "YEAST AWAKENED", nameJa: "イースト菌覚醒" },
    { min: 10000, nameEn: "MASTER CHEF",    nameJa: "熟練シェフ" },
    { min: 6000, nameEn: "VETERAN BAKER",   nameJa: "ベテランパン屋" },
    { min: 3000, nameEn: "APPRENTICE",      nameJa: "見習い" },
    { min: 1000, nameEn: "PART-TIMER",      nameJa: "アルバイト" },
    { min: 0,     nameEn: "CUSTOMER",        nameJa: "お客さん" }
];

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        setTimeout(() => this.resize(), 100);
        window.addEventListener('resize', () => this.resize());
        this.state = 'menu';
        this.score = 0;
        this.maxTime = 90; 
        this.timeLeft = this.maxTime;
        this.targetNum = 0;
        this.entities = [];
        this.formulaStack = [];
        this.clearCount = 0;
        this.feverTimer = 0;
        this.feverMaxTime = 10;
        this.feverType = null;
        this.effects = [];
        this.radarRadius = 0;
        this.centerX = 0;
        this.centerY = 0;
        this.lastTime = 0;
        this.scanAngle = 0;
        this.canvas.addEventListener('pointerdown', (e) => this.handleClick(e));
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.canvas.style.width = this.width + 'px';
        this.canvas.style.height = this.height + 'px';
        this.ctx.scale(dpr, dpr);
        const topSpace = 180; const bottomSpace = 180; 
        this.centerY = topSpace + (this.height - topSpace - bottomSpace) / 2;
        this.centerX = this.width / 2;
        const maxRadius = Math.min(this.width, (this.height - topSpace - bottomSpace)) / 2;
        this.radarRadius = Math.max(0, maxRadius - 10);
        // ★修正：リサイズ時にエンティティが消えないように調整
        if (this.state === 'playing' && this.entities.length === 0) {
             this.replenishEntities();
        }
    }

    start() {
        this.resize();
        this.state = 'playing';
        this.score = 0;
        this.timeLeft = this.maxTime;
        this.clearCount = 0;
        this.updateGauge();
        this.updateTimeBar();
        this.formulaStack = [];
        this.entities = [];
        this.effects = [];
        
        this.replenishEntities();

        this.generateTarget();
        this.updateUI();
        this.clearFormula();
        document.body.classList.remove('fever-mode');
        document.getElementById('menu-screen').classList.add('hidden');
        document.getElementById('gameover-screen').classList.add('hidden');
        this.checkDeadlock();
    }

    generateTarget() {
        this.targetNum = Math.floor(Math.random() * 31);
        document.getElementById('target-display').innerText = this.targetNum;
        document.getElementById('target-label').innerText = "TARGET";
        this.addEffect({type: 'text', text: 'TARGET UPDATED', color: '#FFDC00', size: 20});
    }

    // ★改良：画面サイズに応じて個数を調整
    replenishEntities() {
        // スマホ(小)なら小さくたくさん、PCなら適度なサイズ
        const area = this.width * this.height;
        let targetCount = 20; // Default
        if (this.width < 400) targetCount = 16; 
        else if (this.width > 800) targetCount = 25;

        let currentCount = this.entities.length;
        let needed = targetCount - currentCount;
        for (let i = 0; i < needed; i++) {
            this.spawnEntity(false);
        }
    }

    spawnEntity(isFever) {
        // ★改良：画面サイズに応じた半径計算
        const baseR = Math.min(this.width, this.height) / 13; // 画面の1/13サイズ
        const r = Math.max(18, Math.min(28, baseR)); // 最小18px, 最大28pxに制限

        let x, y, safe = false, attempts = 0;
        const maxAttempts = 150; 
        while (!safe && attempts < maxAttempts) {
            attempts++;
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.sqrt(Math.random()) * (this.radarRadius - r - 5);
            x = this.centerX + Math.cos(angle) * dist;
            y = this.centerY + Math.sin(angle) * dist;
            safe = true;
            for (let ent of this.entities) {
                const d = Math.hypot(ent.x - x, ent.y - y);
                if (d < r * 2.1) { safe = false; break; } // 少し重なり判定を緩和(2.2->2.1)
            }
        }
        if (!safe) return;
        const ent = { 
            type: isFever ? 'num' : (Math.random() < 0.5 ? 'num' : 'op'),
            val: 0, x: x, y: y, r: r, selected: false, isFever: !!isFever, scale: 0
        };
        if (ent.type === 'num') {
            ent.val = Math.floor(Math.random() * 20);
        } else {
            const keys = Object.keys(OPS);
            ent.val = keys[Math.floor(Math.random() * keys.length)];
        }
        this.entities.push(ent);
    }

    calc(val1, op, val2) {
        if (op === 'add') return val1 + val2;
        if (op === 'sub') return val1 - val2;
        if (op === 'mul') return val1 * val2;
        if (op === 'div') {
            if (val2 === 0) return null;
            if (val1 % val2 !== 0) return null;
            return val1 / val2;
        }
        return 0;
    }

    checkDeadlock() {
        if (this.state !== 'playing') return;
        const sol = this.findSolutionDeep(); // ★AI強化版を使用
        if (!sol) {
            this.addEffect({text: "DEADLOCK... RESHUFFLE", color: "#FF4136", size: 24});
            setTimeout(() => {
                this.entities = [];
                this.clearFormula();
                this.replenishEntities();
                // リシャッフル後にもう一度チェックはしない（無限ループ防止）
            }, 800);
        }
    }

    // ★改良：3手読み (Num Op Num Op Num) 対応
    findSolutionDeep() {
        const nums = this.entities.filter(e => e.type === 'num' && !e.selected);
        const ops = this.entities.filter(e => e.type === 'op' && !e.selected);
        const operations = ['add', 'sub', 'mul', 'div'];

        // 1. 単体
        for (let n of nums) {
            if (n.val === this.targetNum) return [n];
        }

        // 2. 3点 (N O N)
        for (let i = 0; i < nums.length; i++) {
            for (let j = 0; j < nums.length; j++) {
                if (i === j) continue;
                const n1 = nums[i].val;
                const n2 = nums[j].val;
                for (let opKey of operations) {
                    const opEnt = ops.find(o => o.val === opKey);
                    if (!opEnt) continue;
                    const res = this.calc(n1, opKey, n2);
                    if (res !== null && res === this.targetNum) {
                        return [nums[i], opEnt, nums[j]];
                    }
                }
            }
        }

        // 3. 5点 (N O N O N) ★ここを追加
        // 計算量を抑えるため、制限時間付き探索や、早期リターンを行う
        // ここでは簡易的に実装
        for (let i = 0; i < nums.length; i++) {
            for (let j = 0; j < nums.length; j++) {
                if (i === j) continue;
                for (let k = 0; k < nums.length; k++) {
                    if (k === i || k === j) continue;
                    
                    const n1 = nums[i].val;
                    const n2 = nums[j].val;
                    const n3 = nums[k].val;

                    for (let op1Key of operations) {
                        const op1Ent = ops.find(o => o.val === op1Key);
                        if (!op1Ent) continue;
                        
                        const res1 = this.calc(n1, op1Key, n2);
                        if (res1 === null) continue;

                        for (let op2Key of operations) {
                             // op1と同じ記号を使う場合、2つ以上あるかチェックが必要だが
                             // 簡易版として、別のエンティティとみなして検索
                             // (厳密には ops配列から op1Ent を除外して探すべき)
                             const op2Ent = ops.find(o => o.val === op2Key && o !== op1Ent);
                             if (!op2Ent) continue;

                             const res2 = this.calc(res1, op2Key, n3);
                             if (res2 !== null && res2 === this.targetNum) {
                                 return [nums[i], op1Ent, nums[j], op2Ent, nums[k]];
                             }
                        }
                    }
                }
            }
        }

        return null;
    }

    autoLock() {
        if (this.state !== 'playing') return;
        this.clearFormula();
        
        // ★AI強化版呼び出し
        const solution = this.findSolutionDeep();
        
        if (solution) {
            let delay = 0;
            solution.forEach(ent => {
                setTimeout(() => {
                    this.trySelectNormal(ent);
                }, delay);
                delay += 80; // 少し高速化
            });
            this.addEffect({text: "AUTO LOCK!!", color: "#FFD700", size: 30});
        } else {
            // ★改良：解がない場合は明示してリシャッフル
            this.addEffect({text: "NO SOLUTION...", color: "#FF4136", size: 20});
            setTimeout(() => this.manualShuffle(), 500);
        }
    }

    manualShuffle() {
        if (this.state !== 'playing') return;
        this.entities = [];
        this.clearFormula();
        this.replenishEntities();
        this.addEffect({text: "RESHUFFLE!", color: "#FFA500", size: 24});
        // シャッフル後、少し待ってからデッドロックチェック
        setTimeout(() => this.checkDeadlock(), 500);
    }

    handleClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        for (let i = 0; i < this.entities.length; i++) {
            const ent = this.entities[i];
            const dist = Math.hypot(ent.x - clickX, ent.y - clickY);
            if (dist < ent.r + 15) {
                if (this.state === 'playing') {
                    this.trySelectNormal(ent);
                } else if (this.state === 'fever') {
                    this.trySelectFever(ent, i);
                }
                return;
            }
        }
    }

    trySelectFever(ent, index) {
        let isValid = false;
        const allVals = this.entities.map(e => e.val);
        if (this.feverType.id === 'asc') {
            const minVal = Math.min(...allVals); if (ent.val === minVal) isValid = true;
        } else if (this.feverType.id === 'desc') {
            const maxVal = Math.max(...allVals); if (ent.val === maxVal) isValid = true;
        } else if (this.feverType.id === 'even') {
            if (ent.val % 2 === 0) isValid = true;
        } else if (this.feverType.id === 'odd') {
            if (ent.val % 2 !== 0) isValid = true;
        }
        if (isValid) {
            this.score += 500;
            this.addEffect({text: '+500', x: ent.x, y: ent.y, color: '#FFDC00'});
            this.entities.splice(index, 1);
        } else {
            this.addEffect({text: 'MISS', x: ent.x, y: ent.y, color: '#888'});
        }
        this.updateUI();
    }

    trySelectNormal(ent) {
        if (ent.selected) return;
        const lastItem = this.formulaStack[this.formulaStack.length - 1];
        if (!lastItem) {
            if (ent.type !== 'num') { this.addEffect({text: "Select NUMBER!", x: ent.x, y: ent.y, color: '#FF4136'}); return; }
        } else {
            if (lastItem.entity.type === 'num' && ent.type === 'num') { this.addEffect({text: "Select SYMBOL!", x: ent.x, y: ent.y, color: '#FF4136'}); return; }
            if (lastItem.entity.type === 'op' && ent.type === 'op') { this.addEffect({text: "Select NUMBER!", x: ent.x, y: ent.y, color: '#FF4136'}); return; }
        }
        ent.selected = true;
        ent.order = this.formulaStack.length + 1;
        this.formulaStack.push({ entity: ent, time: Date.now() });
        this.addEffect({text: 'LOCK', x: ent.x, y: ent.y - 30, color: '#00FFFF', life: 10, size: 12});
        this.updateFormulaBar();
        this.updateGuide();
        this.checkFireReady();
    }

    clearFormula() {
        this.entities.forEach(e => { e.selected = false; e.order = null; });
        this.formulaStack = [];
        this.updateFormulaBar();
        this.updateGuide();
        this.checkFireReady();
    }

    updateFormulaBar() {
        const bar = document.getElementById('formula-bar');
        if (this.formulaStack.length === 0) {
            bar.innerText = "STANDBY..."; bar.style.color = "#666"; return;
        }
        let displayStr = "";
        if (this.formulaStack.length >= 1) { displayStr = `${this.formulaStack[0].entity.val}`; }
        for (let i = 1; i < this.formulaStack.length; i += 2) {
            const opEnt = this.formulaStack[i].entity;
            const opStr = OPS[opEnt.val].op;
            if (i + 1 < this.formulaStack.length) {
                const numEnt = this.formulaStack[i+1].entity;
                displayStr = `(${displayStr} ${opStr} ${numEnt.val})`;
            } else { displayStr = `${displayStr} ${opStr} ?`; }
        }
        bar.innerText = displayStr; bar.style.color = "#00FFFF";
    }

    updateGuide() {
        const msg = document.getElementById('guide-msg');
        if (this.state === 'fever') return;
        if (this.formulaStack.length === 0) {
            msg.innerHTML = `LOCK: [NUMBER]<span class="sub">数字をロックせよ</span>`; msg.style.color = "#FFDC00";
        } else {
            const last = this.formulaStack[this.formulaStack.length-1].entity;
            if (last.type === 'num') {
                msg.innerHTML = `LOCK: [SYMBOL]<span class="sub">記号をロックせよ</span>`; msg.style.color = "#2ECC40";
            } else {
                msg.innerHTML = `LOCK: [NUMBER]<span class="sub">数字をロックせよ</span>`; msg.style.color = "#FFDC00";
            }
        }
    }

    checkFireReady() {
        const btn = document.getElementById('fire-btn');
        const len = this.formulaStack.length;
        if (len >= 1 && this.formulaStack[len-1].entity.type === 'num') { btn.classList.add('ready'); } else { btn.classList.remove('ready'); }
    }

    fire() {
        if (this.state !== 'playing' || this.formulaStack.length === 0) return;
        if (this.formulaStack[this.formulaStack.length-1].entity.type === 'op') {
            this.addEffect({text: "Finish with NUMBER!", color: '#FF4136'}); return;
        }
        let result = this.formulaStack[0].entity.val;
        let scoreBonus = 0;
        let valid = true; 
        for (let i = 1; i < this.formulaStack.length; i += 2) {
            const op = this.formulaStack[i].entity.val;
            const num = this.formulaStack[i+1].entity.val;
            const res = this.calc(result, op, num);
            if (res === null) { valid = false; break; }
            result = res;
            if (op === 'mul') scoreBonus += 300;
            if (op === 'div') scoreBonus += 1000; 
        }
        if (valid && result === this.targetNum) {
            const len = this.formulaStack.length;
            let totalScore = 0;
            if (len === 1) { totalScore = 10; } else {
                let multiplier = 1.0;
                if (len >= 5) multiplier = 1.5;
                if (len >= 7) multiplier = 2.5;
                const baseScore = len * 100;
                totalScore = Math.floor((baseScore + scoreBonus) * multiplier);
            }
            this.score += totalScore;
            this.addEffect({text: `HIT!! +${totalScore}`, color: '#FFDC00', size: 40});
            this.clearCount++;
            this.updateGauge();
            if (this.clearCount >= 3) { this.startFever(); } else {
                this.generateTarget();
                this.entities = this.entities.filter(e => !e.selected);
                this.replenishEntities();
                this.checkDeadlock(); 
            }
        } else {
            const disp = valid ? Math.round(result) : "INVALID";
            this.addEffect({text: `MISS (${disp})`, color: '#888', size: 30});
            this.entities.forEach(e => { e.selected = false; e.order = null; });
        }
        this.formulaStack = [];
        this.updateFormulaBar();
        this.updateGuide();
        this.checkFireReady();
        this.updateUI();
    }

    updateUI() {
        document.getElementById('score-display').innerText = `SCORE: ${this.score}`;
        document.getElementById('timer-display').innerText = `TIME: ${Math.floor(this.timeLeft)}`;
    }

    startFever() {
        this.state = 'fever';
        this.feverTimer = this.feverMaxTime;
        document.body.classList.add('fever-mode');
        this.entities = [];
        this.formulaStack = [];
        this.feverType = FEVER_TYPES[Math.floor(Math.random() * FEVER_TYPES.length)];
        document.getElementById('target-display').innerText = "FEVER!!";
        document.getElementById('target-label').innerText = "MODE";
        const guideMsg = document.getElementById('guide-msg');
        guideMsg.innerHTML = `${this.feverType.labelEn}<span class="sub">${this.feverType.labelJa}</span>`;
        guideMsg.style.color = "#FF4136";
        document.getElementById('formula-bar').innerText = "DESTROY TARGETS!";
        for(let i=0; i<20; i++) { this.spawnEntity(true); }
        this.addEffect({type: 'text', text: 'FEVER START!!', color: '#FF4136', size: 30});
        this.updateTimeBar();
    }

    endFever() {
        this.state = 'playing';
        document.body.classList.remove('fever-mode');
        this.entities = [];
        this.clearCount = 0;
        this.updateGauge();
        this.replenishEntities();
        this.generateTarget();
        this.clearFormula();
        this.updateTimeBar();
        this.checkDeadlock();
    }

    updateGauge() {
        const pct = Math.min(100, (this.clearCount / 3) * 100);
        document.getElementById('fever-gauge').style.width = `${pct}%`;
    }
    
    updateTimeBar() {
        const bar = document.getElementById('time-bar');
        if (this.state === 'fever') {
            const pct = Math.max(0, (this.feverTimer / this.feverMaxTime) * 100);
            bar.style.width = `${pct}%`; bar.style.backgroundColor = '#FF4136'; 
        } else {
            const pct = Math.max(0, (this.timeLeft / this.maxTime) * 100);
            bar.style.width = `${pct}%`;
            if (pct < 20) bar.style.backgroundColor = '#FF4136'; 
            else if (pct < 50) bar.style.backgroundColor = '#FFDC00'; 
            else bar.style.backgroundColor = '#0074D9'; 
        }
    }

    update(dt) {
        this.scanAngle += dt * 2;
        this.entities.forEach(ent => {
            if (ent.scale < 1) ent.scale += dt * 5;
            if (ent.scale > 1) ent.scale = 1;
        });
        if (this.state === 'playing') {
            this.timeLeft -= dt; this.updateTimeBar();
            if (this.timeLeft <= 0) this.gameOver();
        } else if (this.state === 'fever') {
            this.feverTimer -= dt;
            document.getElementById('timer-display').innerText = `FEVER: ${Math.ceil(this.feverTimer)}`;
            this.updateTimeBar(); 
            if (this.feverTimer <= 0) { this.endFever(); }
        }
        for (let i = this.effects.length - 1; i >= 0; i--) {
            let eff = this.effects[i];
            eff.y -= 0.5; eff.life = (eff.life || 50) - 1;
            if (eff.life <= 0) this.effects.splice(i, 1);
        }
    }
    
    gameOver() {
        this.state = 'gameover';
        document.getElementById('gameover-screen').classList.remove('hidden');
        document.getElementById('result-final').innerText = this.score;
        const container = document.getElementById('rank-list-container');
        container.innerHTML = ''; 
        let playerRankFound = false;
        RANKS.forEach(rank => {
            const div = document.createElement('div');
            div.className = 'rank-item';
            let isMyRank = false;
            if (!playerRankFound && this.score >= rank.min) {
                isMyRank = true; playerRankFound = true; div.classList.add('active');
            }
            div.innerHTML = `
                <div class="rank-name-col">
                    <span class="rank-name-en">${rank.nameEn}</span>
                    <span class="rank-name-ja">${rank.nameJa}</span>
                </div>
                <div class="rank-score">${rank.min}</div>
                <div class="rank-arrow">${isMyRank ? '◀ YOU' : ''}</div>
            `;
            container.appendChild(div);
        });
    }

    addEffect({type, text, x, y, color, size, life}) {
        if (x === undefined) x = this.centerX + (Math.random() * 80 - 40);
        if (y === undefined) y = this.centerY + (Math.random() * 80 - 40);
        this.effects.push({
            type: type || 'text', text: text, x: x, y: y,
            color: color || '#FFF', size: size || 20, life: life || 50
        });
    }

    draw() {
        this.ctx.fillStyle = '#050510'; this.ctx.fillRect(0, 0, this.width, this.height);
        const isFever = (this.state === 'fever');
        const radarColor = isFever ? 'rgba(255, 65, 54, 0.3)' : 'rgba(0, 255, 255, 0.2)';
        this.ctx.strokeStyle = radarColor; this.ctx.lineWidth = 2;
        this.ctx.beginPath(); this.ctx.arc(this.centerX, this.centerY, this.radarRadius, 0, Math.PI*2); this.ctx.stroke();
        this.ctx.save(); this.ctx.translate(this.centerX, this.centerY); this.ctx.rotate(this.scanAngle);
        const grad = this.ctx.createLinearGradient(0, 0, this.radarRadius, 0);
        grad.addColorStop(0, 'rgba(0, 255, 255, 0)');
        grad.addColorStop(1, isFever ? 'rgba(255, 65, 54, 0.2)' : 'rgba(0, 255, 255, 0.1)');
        this.ctx.fillStyle = grad; this.ctx.beginPath(); this.ctx.moveTo(0, 0);
        this.ctx.arc(0, 0, this.radarRadius, -0.2, 0.2); this.ctx.fill(); this.ctx.restore();

        if (this.formulaStack.length > 0) {
            const now = Date.now();
            for (let i = 0; i < this.formulaStack.length - 1; i++) {
                const curr = this.formulaStack[i]; const next = this.formulaStack[i+1];
                const age = now - next.time; 
                if (age < 1000) { 
                    const alpha = 1 - (age / 1000);
                    this.ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    this.ctx.lineWidth = 3; this.ctx.shadowBlur = 10; this.ctx.shadowColor = '#00FFFF';
                    this.ctx.beginPath(); this.ctx.moveTo(curr.entity.x, curr.entity.y);
                    this.ctx.lineTo(next.entity.x, next.entity.y); this.ctx.stroke(); this.ctx.shadowBlur = 0;
                } else {
                    this.ctx.strokeStyle = `rgba(0, 255, 255, 0.1)`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath(); this.ctx.moveTo(curr.entity.x, curr.entity.y);
                    this.ctx.lineTo(next.entity.x, next.entity.y); this.ctx.stroke();
                }
            }
        }

        this.entities.forEach(ent => {
            const size = ent.r * ent.scale;
            if (ent.isFever) { this.ctx.fillStyle = '#FF4136'; } else if (ent.type === 'num') {
                this.ctx.fillStyle = ent.selected ? '#FFDC00' : '#EEE';
            } else { this.ctx.fillStyle = ent.selected ? '#00FFFF' : '#0074D9'; }
            this.ctx.beginPath(); this.ctx.arc(ent.x, ent.y, size, 0, Math.PI*2); this.ctx.fill();
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.beginPath(); this.ctx.ellipse(ent.x - size * 0.3, ent.y - size * 0.3, size * 0.2, size * 0.1, Math.PI / 4, 0, Math.PI * 2); this.ctx.fill();

            if (ent.selected) {
                this.drawLockSight(ent.x, ent.y, size + 5);
                if (ent.order) {
                    this.ctx.fillStyle = '#FF4136'; this.ctx.beginPath(); this.ctx.arc(ent.x + 12, ent.y - 12, 8, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.fillStyle = '#fff'; this.ctx.font = 'bold 10px Arial'; this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle'; this.ctx.fillText(ent.order, ent.x + 12, ent.y - 12);
                }
            } else if (ent.isFever) {
                this.ctx.strokeStyle = '#FF0000'; this.ctx.lineWidth = 2; this.ctx.beginPath();
                this.ctx.arc(ent.x, ent.y, size, 0, Math.PI*2); this.ctx.stroke();
            }
            this.ctx.fillStyle = '#000'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
            this.ctx.font = size > 20 ? 'bold 22px Arial' : 'bold 16px Arial';
            let label = ent.type === 'num' ? ent.val : OPS[ent.val].label;
            this.ctx.fillText(label, ent.x, ent.y);
        });

        this.effects.forEach(eff => {
            this.ctx.fillStyle = eff.color; this.ctx.font = `bold ${eff.size || 20}px Arial`;
            this.ctx.textAlign = 'center'; this.ctx.fillText(eff.text, eff.x, eff.y);
        });
    }

    drawLockSight(x, y, r) {
        this.ctx.strokeStyle = '#00FFFF'; this.ctx.lineWidth = 2; this.ctx.shadowBlur = 5; this.ctx.shadowColor = '#00FFFF';
        const gap = Math.PI / 4; 
        this.ctx.beginPath(); this.ctx.arc(x, y, r, Math.PI + gap, 1.5 * Math.PI - gap); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.arc(x, y, r, 1.5 * Math.PI + gap, 2 * Math.PI - gap); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.arc(x, y, r, 0 + gap, 0.5 * Math.PI - gap); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.arc(x, y, r, 0.5 * Math.PI + gap, Math.PI - gap); this.ctx.stroke();
        this.ctx.shadowBlur = 0;
    }

    loop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp; this.update(dt); this.draw();
        requestAnimationFrame(this.loop);
    }
}

window.onload = () => { window.game = new Game(); };
</script>
</body>
</html>
