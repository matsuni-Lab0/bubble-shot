<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bubble Shot: Radar Burst - Undefined Blue</title>
    <style>
        /* --- 伝統のUIスタイルを完全維持 --- */
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: 'Helvetica Neue', Arial, sans-serif; touch-action: none; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100dvh; background-color: #050510; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }

        #top-area { height: 180px; display: flex; flex-direction: column; align-items: center; background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0)); z-index: 10; padding-top: 10px; box-sizing: border-box; position: relative; }
        #commander-window { position: absolute; top: 10px; left: 10px; width: 70px; height: 70px; background: rgba(0, 20, 40, 0.6); border: 2px solid #00FFFF; border-radius: 10px; clip-path: polygon(15% 0, 100% 0, 100% 85%, 85% 100%, 0 100%, 0 15%); pointer-events: auto; display: flex; justify-content: center; align-items: center; z-index: 25; backdrop-filter: blur(2px); }
        #comm-canvas { width: 100%; height: 100%; }
        
        /* ミッション表示（ターゲットの代わり） */
        #mission-label { font-size: 10px; color: #00FFFF; letter-spacing: 4px; margin-top: 5px; opacity: 0.8;}
        #mission-display { font-size: 42px; font-weight: 900; color: #FFDC00; line-height: 1.0; margin: 0; text-shadow: 0 0 20px rgba(255, 220, 0, 0.8); font-family: 'Arial Black', sans-serif; letter-spacing: -1px; text-align: center; }
        #mission-sub { font-size: 14px; color: #00FFFF; font-weight: bold; margin-top: 5px; text-shadow: 0 0 5px #00FFFF; }

        #sync-ratio-label { font-size: 10px; color: #888; margin-top: 10px; letter-spacing: 2px;}
        #sync-gauge-container { width: 200px; height: 6px; background: #333; border-radius: 3px; overflow: hidden; margin-top: 2px; border: 1px solid #555; }
        #sync-gauge { width: 0%; height: 100%; background: linear-gradient(90deg, #00FFFF, #FF00FF); transition: width 0.2s; box-shadow: 0 0 10px #00FFFF; }

        #auto-lock-btn { position: absolute; bottom: 120px; right: 20px; width: 65px; height: 65px; border-radius: 50%; background: rgba(255, 215, 0, 0.2); border: 2px solid #FFD700; color: #FFD700; display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 10px; font-weight: 900; box-shadow: 0 0 15px #FFD700; cursor: pointer; pointer-events: auto; z-index: 30; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); } }

        #status-bar { color: #aaa; font-family: monospace; font-size: 16px; display: flex; gap: 20px; font-weight: bold; margin-top: 5px; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(5, 10, 15, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; text-align: center; }
        .hidden { display: none !important; }
        .btn { padding: 15px 40px; font-size: 18px; background: transparent; border: 2px solid #FFDC00; color: #FFDC00; cursor: pointer; font-weight: bold; box-shadow: 0 0 10px #FFDC00; transition: 0.2s; }
        .btn:hover { background: #FFDC00; color: #000; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="top-area">
            <div id="commander-window">
                <canvas id="comm-canvas" width="70" height="70"></canvas>
            </div>
            <div id="mission-label">MISSION</div>
            <div id="mission-display">READY</div>
            <div id="mission-sub">PLEASE WAIT...</div>
            
            <div id="status-bar">
                <span>SCORE: <span id="score">0</span></span>
                <span>TIME: <span id="timer">90</span></span>
            </div>
            
            <div id="sync-ratio-label">SYNC RATIO</div>
            <div id="sync-gauge-container"><div id="sync-gauge"></div></div>
        </div>

        <div id="auto-lock-btn" onclick="game.autoLock()">
            AUTO<br>LOCK
        </div>

        <div style="height: 100px;"></div> </div>

    <div id="menu-screen" class="overlay">
        <h1 style="color: #00FFFF; font-size: 36px;">BUBBLE SHOT</h1>
        <p>RADAR BURST MODE</p>
        <button class="btn" onclick="game.start()">ENGAGE</button>
    </div>

    <div id="gameover-screen" class="overlay hidden">
        <h1 style="color: #FF4136;">MISSION OVER</h1>
        <p style="font-size: 24px;">SCORE: <span id="final-score">0</span></p>
        <button class="btn" onclick="location.reload()">RETURN</button>
    </div>
</div>

<script>
// ミッション定義（重複排除とスピード感重視）
const MISSIONS = [
    { id: 'odd', title: 'ODD', sub: '奇数を狙え', check: (v) => v % 2 !== 0 },
    { id: 'even', title: 'EVEN', sub: '偶数を狙え', check: (v) => v % 2 === 0 },
    { id: 'asc', title: 'ASCEND', sub: '小さい順に狙え', check: (v, all) => v === Math.min(...all) },
    { id: 'desc', title: 'DESCEND', sub: '大きい順に狙え', check: (v, all) => v === Math.max(...all) }
];

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.commCanvas = document.getElementById('comm-canvas');
        this.commCtx = this.commCanvas.getContext('2d');
        
        this.entities = [];
        this.effects = [];
        this.score = 0;
        this.timeLeft = 90;
        this.syncRatio = 0;
        this.currentMission = null;
        this.state = 'menu';
        this.lastTime = 0;
        this.scanAngle = 0;
        this.bgScroll = 0;

        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.canvas.addEventListener('pointerdown', (e) => this.handleClick(e));
        
        this.updateCommander('normal');
        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.ctx.scale(dpr, dpr);
        this.centerX = this.width / 2;
        this.centerY = 180 + (this.height - 180 - 100) / 2;
        this.radarRadius = Math.min(this.width, this.height - 280) / 2 - 10;
    }

    start() {
        this.state = 'playing';
        this.score = 0;
        this.timeLeft = 90;
        this.syncRatio = 0;
        this.entities = [];
        this.nextMission();
        this.replenish();
        document.getElementById('menu-screen').classList.add('hidden');
    }

    nextMission() {
        this.currentMission = MISSIONS[Math.floor(Math.random() * MISSIONS.length)];
        document.getElementById('mission-display').innerText = this.currentMission.title;
        document.getElementById('mission-sub').innerText = this.currentMission.sub;
        this.updateCommander('normal');
    }

    replenish() {
        const targetCount = 18;
        while (this.entities.length < targetCount) {
            this.spawnEntity();
        }
    }

    spawnEntity() {
        const r = 22;
        let x, y, val, attempts = 0;
        const currentVals = this.entities.map(e => e.val);

        // 重複排除ロジック
        while(attempts < 100) {
            val = Math.floor(Math.random() * 31);
            if (!currentVals.includes(val)) break;
            attempts++;
        }

        attempts = 0;
        while(attempts < 100) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.sqrt(Math.random()) * (this.radarRadius - r - 5);
            x = this.centerX + Math.cos(angle) * dist;
            y = this.centerY + Math.sin(angle) * dist;
            let safe = true;
            for(let e of this.entities) {
                if(Math.hypot(e.x - x, e.y - y) < r * 2.2) { safe = false; break; }
            }
            if(safe) {
                this.entities.push({ x, y, r, val, scale: 0, lockTime: 0 });
                return;
            }
            attempts++;
        }
    }

    handleClick(e) {
        if(this.state !== 'playing') return;
        const rect = this.canvas.getBoundingClientRect();
        const tx = e.clientX - rect.left;
        const ty = e.clientY - rect.top;

        for(let i = this.entities.length - 1; i >= 0; i--) {
            const ent = this.entities[i];
            if(Math.hypot(ent.x - tx, ent.y - ty) < ent.r + 15) {
                this.checkHit(ent, i);
                return;
            }
        }
    }

    autoLock() {
        if(this.state !== 'playing') return;
        const targets = this.entities.filter(e => this.currentMission.check(e.val, this.entities.map(ev => ev.val)));
        if(targets.length > 0) {
            this.updateCommander('happy');
            const target = targets[0];
            const idx = this.entities.indexOf(target);
            this.addEffect("AUTO LOCK", target.x, target.y, "#FFD700", 15);
            setTimeout(() => this.checkHit(target, idx), 100);
        }
    }

    checkHit(ent, index) {
        const allVals = this.entities.map(e => e.val);
        if(this.currentMission.check(ent.val, allVals)) {
            this.score += 150;
            this.syncRatio = Math.min(100, this.syncRatio + 8);
            this.addEffect("HIT!!", ent.x, ent.y, "#00FFFF", 25);
            this.entities.splice(index, 1);
            this.replenish();
            this.updateCommander('happy');
            if(this.syncRatio >= 100) this.fullBurst();
            
            const remaining = this.entities.some(e => this.currentMission.check(e.val, this.entities.map(ev => ev.val)));
            if(!remaining) this.nextMission();
        } else {
            this.syncRatio = Math.max(0, this.syncRatio - 12);
            this.addEffect("MISS", ent.x, ent.y, "#FF4136", 20);
            this.updateCommander('panic');
        }
        this.updateUI();
    }

    fullBurst() {
        this.state = 'burst';
        this.updateCommander('fever');
        this.addEffect("HYMAT FULL BURST!!", this.centerX, this.centerY, "#FF00FF", 40);
        
        setTimeout(() => {
            this.score += this.entities.length * 600;
            this.entities.forEach(ent => this.addEffect("LOCK ON", ent.x, ent.y, "magenta", 12));
            setTimeout(() => {
                this.entities = [];
                this.syncRatio = 0;
                this.state = 'playing';
                this.replenish();
                this.nextMission();
                this.updateUI();
            }, 600);
        }, 500);
    }

    updateUI() {
        document.getElementById('score').innerText = this.score;
        document.getElementById('timer').innerText = Math.floor(this.timeLeft);
        document.getElementById('sync-gauge').style.width = this.syncRatio + '%';
    }

    updateCommander(mood) {
        this.commCtx.clearRect(0,0,70,70);
        this.drawEbiFace(this.commCtx, 35, 35, 25, mood);
    }

    drawEbiFace(ctx, x, y, size, mood) {
        ctx.fillStyle = mood === 'fever' ? '#FF4136' : (mood === 'panic' ? '#A0A0FF' : '#FFDB58');
        ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#8B4513';
        ctx.beginPath(); ctx.ellipse(x-size*0.4, y-size*0.5, size*0.2, size*0.1, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(x+size*0.3, y-size*0.4, size*0.25, size*0.15, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(x-size*0.3, y+size*0.1, size*0.1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x+size*0.3, y+size*0.1, size*0.1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.lineWidth = 2;
        if(mood==='happy'||mood==='fever') ctx.arc(x, y+size*0.1, size*0.3, 0, Math.PI); else ctx.arc(x, y+size*0.2, size*0.3, 0.2*Math.PI, 0.8*Math.PI);
        ctx.stroke();
    }

    loop(t) {
        const dt = (t - this.lastTime) / 1000;
        this.lastTime = t;
        if(this.state === 'playing') {
            this.timeLeft -= dt;
            if(this.timeLeft <= 0) {
                this.state = 'gameover';
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('final-score').innerText = this.score;
            }
            this.updateUI();
        }
        this.scanAngle += dt * 2;
        this.bgScroll += dt * 30;
        this.draw();
        requestAnimationFrame((t) => this.loop(t));
    }

    draw() {
        this.ctx.fillStyle = '#050510'; this.ctx.fillRect(0, 0, this.width, this.height);
        
        // レーダー背景描画
        const ctx = this.ctx;
        ctx.save(); ctx.translate(this.centerX, this.centerY);
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
        for(let i=0; i<this.radarRadius; i+=50) { ctx.beginPath(); ctx.arc(0,0,i,0,Math.PI*2); ctx.stroke(); }
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0,0,this.radarRadius,0,Math.PI*2); ctx.stroke();
        ctx.save(); ctx.rotate(this.scanAngle);
        const g = ctx.createLinearGradient(0,0,this.radarRadius,0); g.addColorStop(0,'transparent'); g.addColorStop(1,'rgba(0,255,255,0.2)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,this.radarRadius,-0.2,0.2); ctx.fill();
        ctx.restore(); ctx.restore();

        // バブル描画
        this.entities.forEach(ent => {
            if(ent.scale < 1) ent.scale += 0.1;
            const s = ent.r * ent.scale;
            ctx.beginPath(); ctx.arc(ent.x, ent.y, s, 0, Math.PI*2);
            ctx.fillStyle = this.state === 'burst' ? 'rgba(255,0,255,0.5)' : 'rgba(0,255,255,0.1)';
            ctx.fill(); ctx.strokeStyle = this.state === 'burst' ? 'magenta' : 'cyan';
            ctx.lineWidth = 2; ctx.stroke();
            // ターゲットロック表示
            if(this.currentMission.check(ent.val, this.entities.map(ev => ev.val))) {
                ctx.strokeStyle = 'rgba(255, 220, 0, 0.5)';
                ctx.beginPath(); ctx.arc(ent.x, ent.y, s + 5, 0, Math.PI*2); ctx.stroke();
            }
            ctx.fillStyle = 'white'; ctx.font = 'bold 18px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(ent.val, ent.x, ent.y);
        });

        // エフェクト
        for(let i=this.effects.length-1; i>=0; i--) {
            const eff = this.effects[i];
            ctx.globalAlpha = eff.life; ctx.fillStyle = eff.color; ctx.font = `bold ${eff.size}px Arial`;
            ctx.fillText(eff.text, eff.x, eff.y);
            eff.y -= 1; eff.life -= 0.02; if(eff.life <= 0) this.effects.splice(i, 1);
        }
        ctx.globalAlpha = 1;
    }

    addEffect(text, x, y, color, size) { this.effects.push({ text, x, y, color, size, life: 1 }); }
}

window.game = new Game();
</script>
</body>
</html>
