<!DOCTYPE html>
<html lang="en"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bubble Shot: Baker's Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: white;
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100dvh;
            overflow: hidden;
            background-color: #050510;
            /* サイバーパンク×ベーカリーの融合 */
            background-image: 
                linear-gradient(rgba(255, 165, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 165, 0, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* --- 上部エリア --- */
        #top-area {
            height: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0));
            z-index: 10;
            padding-top: 10px;
            box-sizing: border-box;
            position: relative;
        }

        /* 共通ボタン（丸形） */
        .circle-btn {
            position: absolute;
            top: 15px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            cursor: pointer;
            z-index: 20;
            font-weight: bold;
            font-size: 20px;
            transition: transform 0.1s;
            backdrop-filter: blur(4px);
        }
        .circle-btn:active { transform: scale(0.9); }

        /* リセットボタン (左上 - 手動用) */
        #manual-shuffle-btn {
            left: 15px;
            background: rgba(255, 165, 0, 0.1);
            border: 2px solid #FFA500;
            color: #FFA500;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.2);
            font-size: 18px;
        }

        /* オートロックボタン (右下 - 課金アイテム想定) */
        #auto-lock-btn {
            position: absolute;
            bottom: 100px; /* FIREボタンの上あたり */
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.2); /* ゴールド */
            border: 2px solid #FFD700;
            color: #FFD700;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: 900;
            text-align: center;
            box-shadow: 0 0 15px #FFD700;
            cursor: pointer;
            pointer-events: auto;
            z-index: 30;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }

        /* タイムバー */
        #time-bar-wrapper {
            width: 60%;
            height: 8px;
            background: #222;
            border-radius: 4px;
            margin-bottom: 8px;
            border: 1px solid #555;
            position: relative;
            overflow: hidden;
        }
        #time-bar {
            width: 100%;
            height: 100%;
            background: #0074D9;
            transition: width 0.1s linear, background 0.3s;
            box-shadow: 0 0 10px currentColor;
        }
        
        #target-label { font-size: 10px; color: #00FFFF; letter-spacing: 4px; margin-top: 5px; opacity: 0.8;}
        #target-display {
            font-size: 64px;
            font-weight: 900;
            color: #FFDC00;
            line-height: 1.0;
            margin: 0;
            text-shadow: 0 0 20px rgba(255, 220, 0, 0.8);
            font-family: 'Arial Black', sans-serif;
            letter-spacing: -2px;
        }
        #status-bar {
            color: #aaa;
            font-family: monospace;
            font-size: 16px;
            display: flex;
            gap: 20px;
            font-weight: bold;
            margin-top: 5px;
            text-shadow: 0 0 2px #000;
        }

        /* フィーバーゲージ */
        #fever-label { font-size: 10px; color: #888; margin-top: 5px; letter-spacing: 2px;}
        #fever-gauge-container {
            width: 200px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 2px;
        }
        #fever-gauge {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #FFDC00, #FF4136);
            transition: width 0.3s;
            box-shadow: 0 0 5px #FF4136;
        }

        /* --- 下部エリア --- */
        #bottom-area {
            height: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 30px;
            background: linear-gradient(to top, rgba(0,20,30,0.95) 60%, rgba(0,0,0,0));
            z-index: 10;
        }

        #guide-msg {
            color: #00FFFF;
            font-size: 12px;
            margin-bottom: 5px;
            min-height: 20px;
            text-shadow: 0 0 5px #00FFFF;
            letter-spacing: 1px;
        }

        #formula-bar {
            min-height: 30px;
            margin-bottom: 15px;
            font-size: 24px; 
            color: #FFF;
            font-family: monospace;
            font-weight: bold;
            text-shadow: 0 0 5px #00FFFF, 0 0 10px #00FFFF;
            white-space: nowrap;
            max-width: 90%;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #btn-group {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #fire-btn {
            width: 150px;
            height: 60px;
            background: rgba(255, 65, 54, 0.1);
            border: 2px solid #555;
            color: #555;
            font-size: 24px;
            font-weight: 900;
            letter-spacing: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            /* 六角形風クリップ */
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            transition: all 0.2s;
            cursor: pointer;
            pointer-events: none;
        }
        #fire-btn.ready {
            background: rgba(255, 65, 54, 0.8);
            border: none; 
            color: white;
            box-shadow: 0 0 30px #FF4136;
            pointer-events: auto;
            transform: scale(1.05);
            text-shadow: 0 0 10px white;
        }
        #fire-btn:active { transform: scale(0.95); background: #fff; color: #FF4136; }

        #clear-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 1px solid #00FFFF;
            color: #00FFFF;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            cursor: pointer;
            background: rgba(0, 255, 255, 0.05);
            pointer-events: auto;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.2);
        }

        /* --- 画面オーバーレイ --- */
        #menu-screen, #gameover-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 15, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            pointer-events: auto;
            z-index: 50;
            text-align: center;
            box-sizing: border-box;
            padding: 40px 20px;
            overflow-y: auto;
        }
        #menu-screen { justify-content: center; }

        h1 { 
            color: #00FFFF; 
            font-size: 36px; 
            font-weight: 900;
            text-shadow: 0 0 10px #00FFFF, 0 0 30px #00FFFF; 
            margin: 10px 0;
            letter-spacing: 4px;
            font-style: italic;
            font-family: 'Arial Black', sans-serif;
        }
        
        .btn {
            padding: 15px 50px;
            font-size: 20px;
            background: transparent;
            border: 2px solid #FFDC00;
            color: #FFDC00;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 10px #FFDC00, inset 0 0 10px #FFDC00;
            transition: all 0.2s;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .btn:hover {
            background: #FFDC00;
            color: #000;
            box-shadow: 0 0 30px #FFDC00;
        }
        
        /* リザルト用 */
        #result-title { color: #FF4136; text-shadow: 0 0 20px #FF4136; margin-bottom: 5px; }
        #result-final { color: #fff; font-size: 48px; font-weight: bold; margin: 0; text-shadow: 0 0 10px white;}
        
        /* ランク一覧スタイル */
        #rank-list-container {
            width: 100%;
            max-width: 350px;
            margin-bottom: 20px;
            text-align: left;
            border-top: 1px solid #333;
            margin-top: 20px;
        }
        .rank-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 5px;
            border-bottom: 1px solid #222;
            font-size: 13px;
            color: #666;
            font-family: monospace;
        }
        .rank-item.active {
            color: #FFDC00;
            background: linear-gradient(90deg, transparent, rgba(255, 220, 0, 0.1), transparent);
            font-weight: bold;
            text-shadow: 0 0 5px #FFDC00;
        }
        .rank-score { width: 60px; text-align: right; }
        .rank-name { flex-grow: 1; padding-left: 10px; }
        .rank-arrow { width: 60px; color: #FF4136; text-align: right; font-weight:bold; animation: blink 0.5s infinite alternate; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }

        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="top-area">
            <div id="manual-shuffle-btn" class="circle-btn" onclick="game.manualShuffle()">↻</div>

            <div id="time-bar-wrapper">
                <div id="time-bar"></div>
            </div>

            <div id="target-label">TARGET</div>
            <div id="target-display">??</div>
            <div id="status-bar">
                <span id="score-display">SCORE: 0</span>
                <span id="timer-display">TIME: 90</span>
            </div>
            
            <div id="fever-label">SYNC RATIO</div>
            <div id="fever-gauge-container">
                <div id="fever-gauge"></div>
            </div>
        </div>
        
        <div style="flex-grow: 1;"></div>
        
        <div id="auto-lock-btn" onclick="game.autoLock()">
            AUTO<br>LOCK
        </div>

        <div id="bottom-area">
            <div id="guide-msg">LOCK: [NUM]</div>
            <div id="formula-bar">READY...</div>
            
            <div id="btn-group">
                <div id="clear-btn" onclick="game.clearFormula()">CLR</div>
                <div id="fire-btn" onclick="game.fire()">FIRE</div>
            </div>
        </div>
    </div>

    <div id="menu-screen">
        <h1>BUBBLE SHOT</h1>
        <p style="color:#00FFFF; font-size:12px; margin-bottom: 20px; font-family: monospace;">
            SYSTEM: ONLINE<br>
            MODE: FULL YEAST BURST
        </p>
        <p style="color:#ccc; font-size:14px; line-height:1.8;">
            Lock on targets to match the number.<br>
            Use <span style="color:#FFD700">AUTO LOCK</span> for instant aim.<br>
            <span style="color:#888; font-size:12px;">(Integer Division Only / Combo High Score)</span>
        </p>
        <button class="btn" onclick="game.start()">BAKE START</button>
    </div>

    <div id="gameover-screen" class="hidden">
        <h1 id="result-title">MISSION OVER</h1>
        
        <p id="result-final">0</p>
        
        <div id="rank-list-container">
            </div>

        <button class="btn" onclick="location.reload()">RE-BAKE</button>
    </div>
</div>

<script>
// ★世界対応：記号化
const OPS = {
    add: { label: '+', op: '+' },
    sub: { label: '-', op: '-' },
    mul: { label: '×', op: '*' },
    div: { label: '÷', op: '/' }
};

const FEVER_TYPES = [
    { id: 'asc', label: 'ASCENDING (Low->High)' },
    { id: 'desc', label: 'DESCENDING (High->Low)' },
    { id: 'even', label: 'EVEN NUMBERS' },
    { id: 'odd', label: 'ODD NUMBERS' }
];

// ★パン用語ランク（IP回避）
const RANKS = [
    { min: 30000, name: "DIVINE BAKER" },     // パンの神
    { min: 20000, name: "YEAST AWAKENED" },   // イースト覚醒 (NEWTYPE)
    { min: 10000, name: "MASTER CHEF" },
    { min: 6000, name: "VETERAN BAKER" },
    { min: 3000, name: "APPRENTICE" },
    { min: 1000, name: "PART-TIMER" },
    { min: 0,     name: "CUSTOMER" }
];

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        setTimeout(() => this.resize(), 100);
        window.addEventListener('resize', () => this.resize());

        this.state = 'menu';
        this.score = 0;
        
        this.maxTime = 90; 
        this.timeLeft = this.maxTime;
        this.targetNum = 0;
        
        this.entities = [];
        this.formulaStack = [];
        this.clearCount = 0;

        this.feverTimer = 0;
        this.feverMaxTime = 10;
        this.feverType = null;

        this.effects = [];
        this.radarRadius = 0;
        this.centerX = 0;
        this.centerY = 0;
        this.lastTime = 0;
        
        this.scanAngle = 0;

        this.canvas.addEventListener('pointerdown', (e) => this.handleClick(e));
        
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * dpr;
        this.canvas.height = this.height * dpr;
        this.canvas.style.width = this.width + 'px';
        this.canvas.style.height = this.height + 'px';
        this.ctx.scale(dpr, dpr);

        const topSpace = 180; 
        const bottomSpace = 180; 
        
        this.centerY = topSpace + (this.height - topSpace - bottomSpace) / 2;
        this.centerX = this.width / 2;
        const maxRadius = Math.min(this.width, (this.height - topSpace - bottomSpace)) / 2;
        this.radarRadius = Math.max(0, maxRadius - 10);
    }

    start() {
        this.resize();
        this.state = 'playing';
        this.score = 0;
        this.timeLeft = this.maxTime;
        this.clearCount = 0;
        this.updateGauge();
        this.updateTimeBar();

        this.formulaStack = [];
        this.entities = [];
        this.effects = [];
        
        const count = (this.width < 400) ? 14 : 20;
        this.replenishEntities(count);

        this.generateTarget();
        this.updateUI();
        this.clearFormula();
        
        document.body.classList.remove('fever-mode');
        document.getElementById('menu-screen').classList.add('hidden');
        document.getElementById('gameover-screen').classList.add('hidden');
        
        // 最初のチェック
        this.checkDeadlock();
    }

    generateTarget() {
        this.targetNum = Math.floor(Math.random() * 31);
        document.getElementById('target-display').innerText = this.targetNum;
        document.getElementById('target-label').innerText = "TARGET";
        this.addEffect({type: 'text', text: 'TARGET UPDATED', color: '#FFDC00', size: 20});
    }

    replenishEntities(targetCount) {
        let currentCount = this.entities.length;
        let needed = targetCount - currentCount;
        for (let i = 0; i < needed; i++) {
            this.spawnEntity(false);
        }
    }

    spawnEntity(isFever) {
        const r = (this.width < 400) ? 22 : 28; 
        let x, y, safe = false, attempts = 0;
        const maxAttempts = 150; 
        
        while (!safe && attempts < maxAttempts) {
            attempts++;
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.sqrt(Math.random()) * (this.radarRadius - r - 5);
            x = this.centerX + Math.cos(angle) * dist;
            y = this.centerY + Math.sin(angle) * dist;
            
            safe = true;
            for (let ent of this.entities) {
                const d = Math.hypot(ent.x - x, ent.y - y);
                if (d < r * 2.2) { safe = false; break; }
            }
        }
        
        if (!safe) return;

        const ent = { 
            type: isFever ? 'num' : (Math.random() < 0.5 ? 'num' : 'op'),
            val: 0,
            x: x, y: y, r: r, 
            selected: false, 
            isFever: !!isFever,
            scale: 0
        };

        if (ent.type === 'num') {
            ent.val = Math.floor(Math.random() * 20);
        } else {
            const keys = Object.keys(OPS);
            ent.val = keys[Math.floor(Math.random() * keys.length)];
        }
        this.entities.push(ent);
    }

    // --- 計算ロジック（割り算は割り切れる時のみ） ---
    calc(val1, op, val2) {
        if (op === 'add') return val1 + val2;
        if (op === 'sub') return val1 - val2;
        if (op === 'mul') return val1 * val2;
        if (op === 'div') {
            // ★Just Division Rule
            if (val2 === 0) return null;
            if (val1 % val2 !== 0) return null; // 割り切れないなら無効
            return val1 / val2;
        }
        return 0;
    }

    // --- 手詰まりチェック＆自動リセット ---
    checkDeadlock() {
        if (this.state !== 'playing') return;
        
        // 解決策があるか探す
        const sol = this.findSolution();
        
        if (!sol) {
            // 解なし -> 自動リセット
            this.addEffect({text: "DEADLOCK... RESHUFFLE", color: "#FF4136", size: 24});
            setTimeout(() => {
                this.entities = [];
                this.clearFormula();
                const count = (this.width < 400) ? 14 : 20;
                this.replenishEntities(count);
                // 再帰チェックは無限ループ防止のため行わないか、カウンタを入れる
            }, 1000);
        }
    }

    // --- 解決策探索（AIロジック） ---
    findSolution() {
        const nums = this.entities.filter(e => e.type === 'num' && !e.selected);
        const ops = this.entities.filter(e => e.type === 'op' && !e.selected);
        const operations = ['add', 'sub', 'mul', 'div'];

        // 単体チェック
        for (let n of nums) {
            if (n.val === this.targetNum) return [n];
        }

        // 3点チェック (Num Op Num)
        for (let i = 0; i < nums.length; i++) {
            for (let j = 0; j < nums.length; j++) {
                if (i === j) continue;
                const n1 = nums[i].val;
                const n2 = nums[j].val;
                
                for (let opKey of operations) {
                    // opEntityがあるか？
                    const hasOp = ops.some(o => o.val === opKey);
                    if (!hasOp) continue;
                    
                    const res = this.calc(n1, opKey, n2);
                    if (res !== null && res === this.targetNum) {
                        // 実際のEntityを特定して返す
                        const opEnt = ops.find(o => o.val === opKey);
                        return [nums[i], opEnt, nums[j]];
                    }
                }
            }
        }
        // 5点チェック (Num Op Num Op Num) は重いので簡易版では省略するか、必要なら実装
        return null;
    }

    // --- 俺TUEEE機能：オートロック（課金想定） ---
    autoLock() {
        if (this.state !== 'playing') return;
        this.clearFormula();

        const solution = this.findSolution();
        if (solution) {
            // 演出：高速ロックオン
            let delay = 0;
            solution.forEach(ent => {
                setTimeout(() => {
                    this.trySelectNormal(ent);
                    // SEを鳴らすならここ
                }, delay);
                delay += 100;
            });
            this.addEffect({text: "AUTO LOCK!!", color: "#FFD700", size: 30});
        } else {
            this.addEffect({text: "SCANNING...", color: "#888", size: 20});
            // 解なしならリシャッフルを促すか、自動発動
            this.manualShuffle(); 
        }
    }

    // 手動シャッフル
    manualShuffle() {
        if (this.state !== 'playing') return;
        this.entities = [];
        this.clearFormula();
        const count = (this.width < 400) ? 14 : 20;
        this.replenishEntities(count);
        this.addEffect({text: "RESHUFFLE!", color: "#FFA500", size: 24});
        this.checkDeadlock();
    }

    handleClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        for (let i = 0; i < this.entities.length; i++) {
            const ent = this.entities[i];
            const dist = Math.hypot(ent.x - clickX, ent.y - clickY);
            if (dist < ent.r + 15) {
                if (this.state === 'playing') {
                    this.trySelectNormal(ent);
                } else if (this.state === 'fever') {
                    this.trySelectFever(ent, i);
                }
                return;
            }
        }
    }

    trySelectFever(ent, index) {
        let isValid = false;
        const allVals = this.entities.map(e => e.val);
        
        if (this.feverType.id === 'asc') {
            const minVal = Math.min(...allVals);
            if (ent.val === minVal) isValid = true;
        } else if (this.feverType.id === 'desc') {
            const maxVal = Math.max(...allVals);
            if (ent.val === maxVal) isValid = true;
        } else if (this.feverType.id === 'even') {
            if (ent.val % 2 === 0) isValid = true;
        } else if (this.feverType.id === 'odd') {
            if (ent.val % 2 !== 0) isValid = true;
        }

        if (isValid) {
            this.score += 500;
            this.addEffect({text: '+500', x: ent.x, y: ent.y, color: '#FFDC00'});
            this.entities.splice(index, 1);
        } else {
            this.addEffect({text: 'MISS', x: ent.x, y: ent.y, color: '#888'});
        }
        this.updateUI();
    }

    trySelectNormal(ent) {
        if (ent.selected) return;
        const lastItem = this.formulaStack[this.formulaStack.length - 1];
        
        if (!lastItem) {
            if (ent.type !== 'num') { this.addEffect({text: "Select NUMBER!", x: ent.x, y: ent.y, color: '#FF4136'}); return; }
        } else {
            if (lastItem.entity.type === 'num' && ent.type === 'num') { this.addEffect({text: "Select SYMBOL!", x: ent.x, y: ent.y, color: '#FF4136'}); return; }
            if (lastItem.entity.type === 'op' && ent.type === 'op') { this.addEffect({text: "Select NUMBER!", x: ent.x, y: ent.y, color: '#FF4136'}); return; }
        }

        ent.selected = true;
        ent.order = this.formulaStack.length + 1;
        this.formulaStack.push({ entity: ent, time: Date.now() });
        
        this.addEffect({text: 'LOCK', x: ent.x, y: ent.y - 30, color: '#00FFFF', life: 10, size: 12});
        
        this.updateFormulaBar();
        this.updateGuide();
        this.checkFireReady();
    }

    clearFormula() {
        this.entities.forEach(e => { e.selected = false; e.order = null; });
        this.formulaStack = [];
        this.updateFormulaBar();
        this.updateGuide();
        this.checkFireReady();
    }

    updateFormulaBar() {
        const bar = document.getElementById('formula-bar');
        if (this.formulaStack.length === 0) {
            bar.innerText = "STANDBY...";
            bar.style.color = "#666";
            return;
        }

        let displayStr = "";
        if (this.formulaStack.length >= 1) {
            displayStr = `${this.formulaStack[0].entity.val}`;
        }

        for (let i = 1; i < this.formulaStack.length; i += 2) {
            const opEnt = this.formulaStack[i].entity;
            const opStr = OPS[opEnt.val].op;

            if (i + 1 < this.formulaStack.length) {
                const numEnt = this.formulaStack[i+1].entity;
                displayStr = `(${displayStr} ${opStr} ${numEnt.val})`;
            } else {
                displayStr = `${displayStr} ${opStr} ?`;
            }
        }

        bar.innerText = displayStr;
        bar.style.color = "#00FFFF";
    }

    updateGuide() {
        const msg = document.getElementById('guide-msg');
        if (this.state === 'fever') return;

        if (this.formulaStack.length === 0) {
            msg.innerText = "LOCK: [NUMBER]";
            msg.style.color = "#FFDC00";
        } else {
            const last = this.formulaStack[this.formulaStack.length-1].entity;
            if (last.type === 'num') {
                msg.innerText = "LOCK: [SYMBOL]";
                msg.style.color = "#2ECC40";
            } else {
                msg.innerText = "LOCK: [NUMBER]";
                msg.style.color = "#FFDC00";
            }
        }
    }

    checkFireReady() {
        const btn = document.getElementById('fire-btn');
        const len = this.formulaStack.length;
        if (len >= 1 && this.formulaStack[len-1].entity.type === 'num') {
            btn.classList.add('ready');
        } else {
            btn.classList.remove('ready');
        }
    }

    fire() {
        if (this.state !== 'playing' || this.formulaStack.length === 0) return;
        if (this.formulaStack[this.formulaStack.length-1].entity.type === 'op') {
            this.addEffect({text: "Finish with NUMBER!", color: '#FF4136'}); return;
        }

        let result = this.formulaStack[0].entity.val;
        let scoreBonus = 0;
        let valid = true; // 計算が無効になった場合用
        
        for (let i = 1; i < this.formulaStack.length; i += 2) {
            const op = this.formulaStack[i].entity.val;
            const num = this.formulaStack[i+1].entity.val;

            const res = this.calc(result, op, num);
            if (res === null) {
                valid = false;
                break; 
            }
            
            result = res;
            
            if (op === 'mul') scoreBonus += 300;
            if (op === 'div') scoreBonus += 1000; // 割り算ボーナス大
        }

        if (valid && result === this.targetNum) {
            const len = this.formulaStack.length;
            let totalScore = 0;

            if (len === 1) {
                totalScore = 10;
            } else {
                let multiplier = 1.0;
                if (len >= 5) multiplier = 1.5;
                if (len >= 7) multiplier = 2.5;
                const baseScore = len * 100;
                totalScore = Math.floor((baseScore + scoreBonus) * multiplier);
            }
            
            this.score += totalScore;
            this.addEffect({text: `HIT!! +${totalScore}`, color: '#FFDC00', size: 40});
            
            this.clearCount++;
            this.updateGauge();

            if (this.clearCount >= 3) {
                this.startFever();
            } else {
                this.generateTarget();
                this.entities = this.entities.filter(e => !e.selected);
                const count = (this.width < 400) ? 14 : 20;
                this.replenishEntities(count);
                this.checkDeadlock(); // 補充後に手詰まりチェック
            }

        } else {
            const disp = valid ? Math.round(result) : "INVALID";
            this.addEffect({text: `MISS (${disp})`, color: '#888', size: 30});
            this.entities.forEach(e => { e.selected = false; e.order = null; });
        }

        this.formulaStack = [];
        this.updateFormulaBar();
        this.updateGuide();
        this.checkFireReady();
        this.updateUI();
    }

    updateUI() {
        document.getElementById('score-display').innerText = `SCORE: ${this.score}`;
        document.getElementById('timer-display').innerText = `TIME: ${Math.floor(this.timeLeft)}`;
    }

    startFever() {
        this.state = 'fever';
        this.feverTimer = this.feverMaxTime;
        document.body.classList.add('fever-mode');
        this.entities = [];
        this.formulaStack = [];
        this.feverType = FEVER_TYPES[Math.floor(Math.random() * FEVER_TYPES.length)];
        
        document.getElementById('target-display').innerText = "FEVER!!";
        document.getElementById('target-label').innerText = "MODE";
        document.getElementById('guide-msg').innerText = this.feverType.label;
        document.getElementById('guide-msg').style.color = "#FF4136";
        document.getElementById('formula-bar').innerText = "DESTROY TARGETS!";
        
        for(let i=0; i<20; i++) {
            this.spawnEntity(true);
        }
        this.addEffect({type: 'text', text: 'FEVER START!!', color: '#FF4136', size: 30});
        this.updateTimeBar();
    }

    endFever() {
        this.state = 'playing';
        document.body.classList.remove('fever-mode');
        this.entities = [];
        this.clearCount = 0;
        this.updateGauge();
        const count = (this.width < 400) ? 14 : 20;
        this.replenishEntities(count);
        this.generateTarget();
        this.clearFormula();
        this.updateTimeBar();
        this.checkDeadlock();
    }

    updateGauge() {
        const pct = Math.min(100, (this.clearCount / 3) * 100);
        document.getElementById('fever-gauge').style.width = `${pct}%`;
    }
    
    updateTimeBar() {
        const bar = document.getElementById('time-bar');
        
        if (this.state === 'fever') {
            const pct = Math.max(0, (this.feverTimer / this.feverMaxTime) * 100);
            bar.style.width = `${pct}%`;
            bar.style.backgroundColor = '#FF4136'; 
        } else {
            const pct = Math.max(0, (this.timeLeft / this.maxTime) * 100);
            bar.style.width = `${pct}%`;
            if (pct < 20) bar.style.backgroundColor = '#FF4136'; 
            else if (pct < 50) bar.style.backgroundColor = '#FFDC00'; 
            else bar.style.backgroundColor = '#0074D9'; 
        }
    }

    update(dt) {
        this.scanAngle += dt * 2;

        this.entities.forEach(ent => {
            if (ent.scale < 1) ent.scale += dt * 5;
            if (ent.scale > 1) ent.scale = 1;
        });

        if (this.state === 'playing') {
            this.timeLeft -= dt;
            this.updateTimeBar();
            if (this.timeLeft <= 0) this.gameOver();
        } else if (this.state === 'fever') {
            this.feverTimer -= dt;
            document.getElementById('timer-display').innerText = `FEVER: ${Math.ceil(this.feverTimer)}`;
            this.updateTimeBar(); 
            if (this.feverTimer <= 0) {
                this.endFever();
            }
        }

        for (let i = this.effects.length - 1; i >= 0; i--) {
            let eff = this.effects[i];
            eff.y -= 0.5;
            eff.life = (eff.life || 50) - 1;
            if (eff.life <= 0) this.effects.splice(i, 1);
        }
    }
    
    gameOver() {
        this.state = 'gameover';
        document.getElementById('gameover-screen').classList.remove('hidden');
        
        document.getElementById('result-final').innerText = this.score;
        
        const container = document.getElementById('rank-list-container');
        container.innerHTML = ''; 
        
        let playerRankFound = false;

        RANKS.forEach(rank => {
            const div = document.createElement('div');
            div.className = 'rank-item';
            
            let isMyRank = false;
            if (!playerRankFound && this.score >= rank.min) {
                isMyRank = true;
                playerRankFound = true; 
                div.classList.add('active');
            }
            div.innerHTML = `
                <div class="rank-name">${rank.name}</div>
                <div class="rank-score">${rank.min}</div>
                <div class="rank-arrow">${isMyRank ? '◀ YOU' : ''}</div>
            `;
            container.appendChild(div);
        });
    }

    addEffect({type, text, x, y, color, size, life}) {
        if (x === undefined) x = this.centerX + (Math.random() * 80 - 40);
        if (y === undefined) y = this.centerY + (Math.random() * 80 - 40);
        
        this.effects.push({
            type: type || 'text',
            text: text,
            x: x,
            y: y,
            color: color || '#FFF',
            size: size || 20,
            life: life || 50
        });
    }

    draw() {
        this.ctx.fillStyle = '#050510';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Grid (handled by CSS)
        
        const isFever = (this.state === 'fever');
        const radarColor = isFever ? 'rgba(255, 65, 54, 0.3)' : 'rgba(0, 255, 255, 0.2)';
        
        this.ctx.strokeStyle = radarColor;
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(this.centerX, this.centerY, this.radarRadius, 0, Math.PI*2);
        this.ctx.stroke();
        
        this.ctx.save();
        this.ctx.translate(this.centerX, this.centerY);
        this.ctx.rotate(this.scanAngle);
        const grad = this.ctx.createLinearGradient(0, 0, this.radarRadius, 0);
        grad.addColorStop(0, 'rgba(0, 255, 255, 0)');
        grad.addColorStop(1, isFever ? 'rgba(255, 65, 54, 0.2)' : 'rgba(0, 255, 255, 0.1)');
        this.ctx.fillStyle = grad;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.arc(0, 0, this.radarRadius, -0.2, 0.2);
        this.ctx.fill();
        this.ctx.restore();

        // リンク線の描画
        if (this.formulaStack.length > 0) {
            const now = Date.now();
            for (let i = 0; i < this.formulaStack.length - 1; i++) {
                const curr = this.formulaStack[i];
                const next = this.formulaStack[i+1];
                const age = now - next.time; 
                
                if (age < 1000) { 
                    const alpha = 1 - (age / 1000);
                    this.ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = '#00FFFF';
                    this.ctx.beginPath();
                    this.ctx.moveTo(curr.entity.x, curr.entity.y);
                    this.ctx.lineTo(next.entity.x, next.entity.y);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                } else {
                    this.ctx.strokeStyle = `rgba(0, 255, 255, 0.1)`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(curr.entity.x, curr.entity.y);
                    this.ctx.lineTo(next.entity.x, next.entity.y);
                    this.ctx.stroke();
                }
            }
        }

        this.entities.forEach(ent => {
            const size = ent.r * ent.scale;
            
            if (ent.isFever) {
                this.ctx.fillStyle = '#FF4136';
            } else if (ent.type === 'num') {
                this.ctx.fillStyle = ent.selected ? '#FFDC00' : '#EEE';
            } else {
                // 記号は青系に
                this.ctx.fillStyle = ent.selected ? '#00FFFF' : '#0074D9';
            }
            
            this.ctx.beginPath();
            this.ctx.arc(ent.x, ent.y, size, 0, Math.PI*2);
            this.ctx.fill();
            
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            this.ctx.beginPath();
            this.ctx.ellipse(ent.x - size * 0.3, ent.y - size * 0.3, size * 0.2, size * 0.1, Math.PI / 4, 0, Math.PI * 2);
            this.ctx.fill();

            if (ent.selected) {
                this.drawLockSight(ent.x, ent.y, size + 5);
                if (ent.order) {
                    this.ctx.fillStyle = '#FF4136';
                    this.ctx.beginPath();
                    this.ctx.arc(ent.x + 12, ent.y - 12, 8, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(ent.order, ent.x + 12, ent.y - 12);
                }
            } else if (ent.isFever) {
                this.ctx.strokeStyle = '#FF0000';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(ent.x, ent.y, size, 0, Math.PI*2);
                this.ctx.stroke();
            }

            this.ctx.fillStyle = '#000';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.font = size > 20 ? 'bold 22px Arial' : 'bold 16px Arial';
            let label = ent.type === 'num' ? ent.val : OPS[ent.val].label;
            this.ctx.fillText(label, ent.x, ent.y);
        });

        this.effects.forEach(eff => {
            this.ctx.fillStyle = eff.color;
            this.ctx.font = `bold ${eff.size || 20}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(eff.text, eff.x, eff.y);
        });
    }

    drawLockSight(x, y, r) {
        this.ctx.strokeStyle = '#00FFFF';
        this.ctx.lineWidth = 2;
        this.ctx.shadowBlur = 5;
        this.ctx.shadowColor = '#00FFFF';
        
        const gap = Math.PI / 4; 
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, Math.PI + gap, 1.5 * Math.PI - gap);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 1.5 * Math.PI + gap, 2 * Math.PI - gap);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0 + gap, 0.5 * Math.PI - gap);
        this.ctx.stroke();
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0.5 * Math.PI + gap, Math.PI - gap);
        this.ctx.stroke();

        this.ctx.shadowBlur = 0;
    }

    loop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        this.update(dt);
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

window.onload = () => {
    window.game = new Game();
};
</script>
</body>
</html>
