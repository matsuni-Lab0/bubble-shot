<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bubble Shot: Burst Action - Undefined Blue</title>
    <style>
        /* CSSは以前のものをベースに、一部アクション向けに調整 */
        body { margin: 0; overflow: hidden; background-color: #050510; color: white; font-family: sans-serif; touch-action: none; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100dvh; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* 上部：ミッション表示 */
        #top-area {
            height: 160px; display: flex; flex-direction: column; align-items: center;
            background: linear-gradient(to bottom, rgba(0,255,255,0.2), transparent);
        }
        #mission-label { font-size: 12px; color: #00FFFF; margin-top: 15px; letter-spacing: 2px; }
        #mission-display { font-size: 32px; font-weight: 900; color: #FFDC00; text-shadow: 0 0 15px #FFDC00; margin: 5px 0; }
        #mission-sub { font-size: 14px; color: #aaa; }

        /* 同期率（SYNC RATIO）ゲージ */
        #sync-container { width: 80%; height: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; margin-top: 15px; border: 1px solid #00FFFF; overflow: hidden; }
        #sync-bar { width: 0%; height: 100%; background: cyan; box-shadow: 0 0 10px cyan; transition: width 0.2s; }

        #status-bar { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: space-around; font-family: monospace; font-size: 20px; }

        /* メニュー・オーバーレイ */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; pointer-events: auto; }
        .hidden { display: none !important; }
        .btn { padding: 15px 40px; font-size: 20px; border: 2px solid #00FFFF; background: none; color: #00FFFF; cursor: pointer; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="top-area">
            <div id="mission-label">CURRENT MISSION</div>
            <div id="mission-display">READY?</div>
            <div id="mission-sub">ミッションを確認せよ</div>
            <div id="sync-container"><div id="sync-bar"></div></div>
            <div style="font-size: 10px; color: cyan; margin-top: 4px;">SYNC RATIO</div>
        </div>
        
        <div id="status-bar">
            <span>SCORE: <span id="score">0</span></span>
            <span>TIME: <span id="timer">90</span></span>
        </div>
    </div>

    <div id="menu-screen" class="overlay">
        <h1 style="color: cyan; font-style: italic;">BUBBLE SHOT</h1>
        <p>FAST ACTION MODE</p>
        <button class="btn" onclick="game.start()">ENGAGE</button>
    </div>

    <div id="gameover-screen" class="overlay hidden">
        <h1>MISSION OVER</h1>
        <p>FINAL SCORE: <span id="final-score">0</span></p>
        <button class="btn" onclick="location.reload()">RETRY</button>
    </div>
</div>

<script>
// ミッション定義
const MISSIONS = [
    { id: 'odd', title: 'ODD NUMBERS', sub: '奇数を撃て', check: (v) => v % 2 !== 0 },
    { id: 'even', title: 'EVEN NUMBERS', sub: '偶数を撃て', check: (v) => v % 2 === 0 },
    { id: 'asc', title: 'ASCENDING', sub: '小さい順に撃て', check: (v, all) => v === Math.min(...all) },
    { id: 'desc', title: 'DESCENDING', sub: '大きい順に撃て', check: (v, all) => v === Math.max(...all) }
];

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.entities = [];
        this.effects = [];
        this.score = 0;
        this.timeLeft = 90;
        this.syncRatio = 0; // 0 to 100
        this.currentMission = null;
        this.state = 'menu';
        this.lastTime = 0;

        this.canvas.addEventListener('pointerdown', (e) => this.handleClick(e));
        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * window.devicePixelRatio;
        this.canvas.height = this.height * window.devicePixelRatio;
        this.canvas.style.width = this.width + 'px';
        this.canvas.style.height = this.height + 'px';
        this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    start() {
        this.state = 'playing';
        this.score = 0;
        this.timeLeft = 90;
        this.syncRatio = 0;
        this.entities = [];
        this.nextMission();
        this.replenish();
        document.getElementById('menu-screen').classList.add('hidden');
    }

    nextMission() {
        this.currentMission = MISSIONS[Math.floor(Math.random() * MISSIONS.length)];
        document.getElementById('mission-display').innerText = this.currentMission.title;
        document.getElementById('mission-sub').innerText = this.currentMission.sub;
        this.addEffect("MISSION UPDATED", this.width/2, this.height/2, "cyan", 30);
    }

    // 重複排除ロジックを含んだ補充
    replenish() {
        const targetCount = 15;
        while (this.entities.length < targetCount) {
            this.spawnEntity();
        }
    }

    spawnEntity() {
        const r = 25;
        let x, y, val, attempts = 0;
        let isSafe = false;

        // 数字の決定（重複排除）
        const currentVals = this.entities.map(e => e.val);
        while(attempts < 50) {
            val = Math.floor(Math.random() * 31);
            // 昇順・降順ミッションの時は特に重複を避ける
            if (!currentVals.includes(val)) break;
            attempts++;
        }

        // 位置の決定
        attempts = 0;
        while(!isSafe && attempts < 50) {
            x = r + Math.random() * (this.width - r * 2);
            y = 180 + Math.random() * (this.height - 300);
            isSafe = true;
            for(let e of this.entities) {
                if(Math.hypot(e.x - x, e.y - y) < r * 2.2) { isSafe = false; break; }
            }
            attempts++;
        }
        if(isSafe) this.entities.push({ x, y, r, val, scale: 0 });
    }

    handleClick(e) {
        if(this.state !== 'playing') return;
        const rect = this.canvas.getBoundingClientRect();
        const tx = e.clientX - rect.left;
        const ty = e.clientY - rect.top;

        for(let i = this.entities.length - 1; i >= 0; i--) {
            const ent = this.entities[i];
            if(Math.hypot(ent.x - tx, ent.y - ty) < ent.r + 10) {
                this.checkHit(ent, i);
                return;
            }
        }
    }

    checkHit(ent, index) {
        const allVals = this.entities.map(e => e.val);
        if(this.currentMission.check(ent.val, allVals)) {
            // HIT
            this.score += 100;
            this.syncRatio = Math.min(100, this.syncRatio + 10);
            this.addEffect("HIT!", ent.x, ent.y, "#FFDC00");
            this.entities.splice(index, 1);
            this.replenish();
            
            if(this.syncRatio >= 100) this.fullBurst();
            
            // 昇順・降順の場合は1つ消すごとに次のターゲットが変わるためミッション表示を維持
            // 奇数・偶数で画面に無くなったら次のミッションへ
            const remainingTarget = this.entities.some(e => this.currentMission.check(e.val, this.entities.map(ev => ev.val)));
            if(!remainingTarget) this.nextMission();

        } else {
            // MISS
            this.syncRatio = Math.max(0, this.syncRatio - 15);
            this.addEffect("MISS", ent.x, ent.y, "#ff4136");
        }
        this.updateUI();
    }

    fullBurst() {
        this.state = 'burst';
        this.addEffect("HYMAT FULL BURST!!", this.width/2, this.height/2, "#FF4136", 40);
        
        // 全弾ロックオン演出
        setTimeout(() => {
            const count = this.entities.length;
            this.score += count * 500;
            this.entities.forEach(ent => {
                this.addEffect("LOCK ON", ent.x, ent.y, "magenta", 15);
            });
            
            setTimeout(() => {
                this.entities = [];
                this.syncRatio = 0;
                this.state = 'playing';
                this.replenish();
                this.nextMission();
                this.updateUI();
            }, 800);
        }, 500);
    }

    updateUI() {
        document.getElementById('score').innerText = this.score;
        document.getElementById('timer').innerText = Math.floor(this.timeLeft);
        document.getElementById('sync-bar').style.width = this.syncRatio + '%';
    }

    addEffect(text, x, y, color, size = 20) {
        this.effects.push({ text, x, y, color, size, life: 1, maxLife: 1 });
    }

    loop(t) {
        const dt = (t - this.lastTime) / 1000;
        this.lastTime = t;

        if(this.state === 'playing') {
            this.timeLeft -= dt;
            if(this.timeLeft <= 0) {
                this.state = 'gameover';
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('final-score').innerText = this.score;
            }
            this.updateUI();
        }

        this.draw();
        requestAnimationFrame((t) => this.loop(t));
    }

    draw() {
        this.ctx.clearRect(0, 0, this.width, this.height);

        // エンティティ描画
        this.entities.forEach(ent => {
            if(ent.scale < 1) ent.scale += 0.1;
            const s = ent.r * ent.scale;
            this.ctx.beginPath();
            this.ctx.arc(ent.x, ent.y, s, 0, Math.PI*2);
            this.ctx.fillStyle = this.state === 'burst' ? 'magenta' : 'rgba(0, 255, 255, 0.2)';
            this.ctx.fill();
            this.ctx.strokeStyle = 'cyan';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();

            this.ctx.fillStyle = 'white';
            this.ctx.font = 'bold 20px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(ent.val, ent.x, ent.y);
        });

        // エフェクト描画
        for(let i = this.effects.length - 1; i >= 0; i--) {
            const eff = this.effects[i];
            this.ctx.globalAlpha = eff.life;
            this.ctx.fillStyle = eff.color;
            this.ctx.font = `bold ${eff.size}px sans-serif`;
            this.ctx.fillText(eff.text, eff.x, eff.y);
            eff.y -= 1;
            eff.life -= 0.02;
            if(eff.life <= 0) this.effects.splice(i, 1);
        }
        this.ctx.globalAlpha = 1;
    }
}

window.game = new Game();
</script>
</body>
</html>
