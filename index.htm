<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bubble Shot: Reflex</title>
    <style>
        /* --- デザイン設定 --- */
        body {
            margin: 0; overflow: hidden; background-color: #050510; color: white;
            font-family: 'Arial Black', sans-serif; touch-action: none; user-select: none;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* UIレイヤー */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
        }

        /* 上部HUD */
        #hud-top {
            padding: 10px 20px; display: flex; justify-content: space-between; align-items: flex-end;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); height: 80px;
        }
        .hud-item { text-align: center; }
        .label { font-size: 10px; color: #888; letter-spacing: 2px; }
        .value { font-size: 24px; color: #fff; text-shadow: 0 0 10px currentColor; }
        
        /* タイムバー */
        #time-bar-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 6px; background: #333;
        }
        #time-bar {
            width: 100%; height: 100%; background: #00ff00; transition: width 0.1s linear;
            box-shadow: 0 0 10px #00ff00;
        }

        /* 中央指令エリア (超重要) */
        #command-area {
            position: absolute; top: 15%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }
        #command-main {
            font-size: 42px; font-weight: 900; color: #fff;
            text-shadow: 0 0 20px #fff; line-height: 1;
            transform: scale(1); transition: transform 0.1s;
        }
        #command-sub {
            font-size: 14px; color: #aaa; margin-top: 5px; font-weight: normal;
        }
        .pulse { animation: pulseBig 0.5s infinite alternate; }
        @keyframes pulseBig { from { transform: scale(1); } to { transform: scale(1.1); } }

        /* 下部エリア (ボス用) */
        #bottom-area {
            margin-top: auto; padding: 20px; text-align: center;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            min-height: 100px; display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
        }
        #formula-display {
            font-size: 24px; color: #00ffff; margin-bottom: 10px; letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffff; min-height: 30px;
        }
        #boss-btn {
            padding: 15px 60px; font-size: 20px; font-weight: bold; background: #ff0055;
            color: #fff; border: 2px solid #fff; border-radius: 50px;
            box-shadow: 0 0 20px #ff0055; pointer-events: auto; display: none; /* ボス戦のみ表示 */
        }
        #boss-btn:active { transform: scale(0.95); }

        /* オーバーレイ */
        #start-screen, #gameover-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto; z-index: 100;
        }
        h1 { font-size: 40px; color: #00ffff; margin: 0; text-shadow: 0 0 20px #00ffff; font-style: italic;}
        .btn-start {
            margin-top: 30px; padding: 15px 50px; font-size: 24px; background: transparent;
            border: 2px solid #00ffff; color: #00ffff; cursor: pointer;
            box-shadow: 0 0 10px #00ffff; font-weight: bold;
        }
        .hidden { display: none !important; }

        /* ダメージエフェクト */
        .damage-flash { animation: flashRed 0.3s; }
        @keyframes flashRed { 0% { background: rgba(255,0,0,0.5); } 100% { background: transparent; } }

    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
    <div id="time-bar-container"><div id="time-bar"></div></div>
    
    <div id="hud-top">
        <div class="hud-item">
            <div class="label">SCORE</div>
            <div class="value" id="score-val">0</div>
        </div>
        <div class="hud-item">
            <div class="label">COMBO</div>
            <div class="value" id="combo-val" style="color:#ffcc00">0</div>
        </div>
    </div>

    <div id="command-area">
        <div id="command-main">READY?</div>
        <div id="command-sub">Tap to Start</div>
    </div>

    <div id="bottom-area">
        <div id="formula-display"></div>
        <button id="boss-btn" onclick="game.fireBossShot()">FIRE!</button>
    </div>
</div>

<div id="start-screen">
    <h1>REFLEX<br>SHOT</h1>
    <p style="color:#ccc; margin-top:10px;">Rapid Fire Puzzle</p>
    <button class="btn-start" onclick="game.start()">START</button>
</div>

<div id="gameover-screen" class="hidden">
    <h1 style="color:#ff0055">TIME UP</h1>
    <p style="color:#fff; font-size:20px;">SCORE: <span id="final-score">0</span></p>
    <button class="btn-start" onclick="location.reload()">RETRY</button>
</div>

<script>
/* * Bubble Shot: Reflex Edition
 * コンセプト：スピード重視の仕分けアクション ＋ 思考型ボス戦
 */

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // 入力処理
        this.canvas.addEventListener('pointerdown', (e) => this.handleInput(e));
        
        // ゲーム状態
        this.state = 'menu'; // menu, playing, boss, gameover
        this.score = 0;
        this.combo = 0;
        this.maxTime = 60;
        this.timeLeft = this.maxTime;
        this.bubbles = [];
        this.particles = [];
        this.floatingTexts = [];
        
        // コマンド（ルール）管理
        this.currentRule = null; // 'odd', 'even', 'asc', 'desc'
        this.lastSelectedVal = -1; // 昇順・降順用
        
        // ボスミッション用
        this.bossMission = null; // { target: 6, constraint: 'mul' }
        this.bossStack = []; // 選択したバブル

        // ループ開始
        this.lastTime = 0;
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        this.dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * this.dpr;
        this.canvas.height = this.height * this.dpr;
        this.ctx.scale(this.dpr, this.dpr);
        
        // バブルサイズ計算
        this.bubbleRadius = Math.min(this.width, this.height) / 8;
    }

    start() {
        document.getElementById('start-screen').classList.add('hidden');
        this.state = 'playing';
        this.score = 0;
        this.timeLeft = this.maxTime;
        this.combo = 0;
        this.bubbles = [];
        this.spawnBubbles(12); // 初期バブル
        this.setNextRule(); // 最初の指令
        this.updateUI();
    }

    // --- ルール管理システム ---
    setNextRule() {
        const rules = [
            { id: 'odd', text: 'ODD', sub: '奇数を撃て！ (1, 3, 5...)', color: '#ff0055' },
            { id: 'even', text: 'EVEN', sub: '偶数を撃て！ (2, 4, 6...)', color: '#00ccff' },
            { id: 'asc', text: 'ASCEND', sub: '小さい順に撃て！ (1→2→3)', color: '#00ff00' },
            { id: 'desc', text: 'DESCEND', sub: '大きい順に撃て！ (9→8→7)', color: '#ffcc00' }
        ];
        
        // ランダムに決定（前回と同じものは避ける）
        let next;
        do {
            next = rules[Math.floor(Math.random() * rules.length)];
        } while (this.currentRule && this.currentRule.id === next.id);

        this.currentRule = next;
        this.lastSelectedVal = -1; // リセット

        // UI更新
        const main = document.getElementById('command-main');
        const sub = document.getElementById('command-sub');
        main.innerText = this.currentRule.text;
        main.style.color = this.currentRule.color;
        sub.innerText = this.currentRule.sub;
        
        // 演出
        main.classList.remove('pulse');
        void main.offsetWidth; // リフロー
        main.classList.add('pulse');
        
        // バブルが足りない・詰むのを防ぐため、必ず正解できるバブルを混ぜる
        this.ensureSolvable(this.currentRule.id);
    }

    ensureSolvable(ruleId) {
        // 盤面に正解があるかチェックし、なければ変化させる
        // 簡易実装：ランダムに1つを正解候補に変える
        if (this.bubbles.length === 0) return;
        
        const targetIdx = Math.floor(Math.random() * this.bubbles.length);
        const b = this.bubbles[targetIdx];
        
        if (ruleId === 'odd') b.val = 1 + 2 * Math.floor(Math.random()*4); // 1,3,5,7
        else if (ruleId === 'even') b.val = 2 + 2 * Math.floor(Math.random()*4); // 2,4,6,8
        else if (ruleId === 'asc') b.val = 1; // スタートしやすい数
        else if (ruleId === 'desc') b.val = 9;
    }

    // --- ボスミッション（計算モード） ---
    startBossMission() {
        this.state = 'boss';
        this.bossStack = [];
        
        // ミッション決定：例「6を作れ（×を使う）」
        const targets = [
            { val: 6, constraint: 'mul', text: 'Target: 6 (Use ×)', sub: '掛け算で 6 を作れ' },
            { val: 12, constraint: 'mul', text: 'Target: 12 (Use ×)', sub: '掛け算で 12 を作れ' },
            { val: 10, constraint: 'add', text: 'Target: 10 (Use +)', sub: '足し算で 10 を作れ' },
            { val: 0, constraint: 'sub', text: 'Target: 0 (Use -)', sub: '引き算で 0 を作れ' }
        ];
        this.bossMission = targets[Math.floor(Math.random() * targets.length)];

        // UI変更
        const main = document.getElementById('command-main');
        const sub = document.getElementById('command-sub');
        main.innerText = "MISSION!";
        main.style.color = "#fff";
        sub.innerText = this.bossMission.sub;
        
        document.getElementById('formula-display').innerText = this.bossMission.text;
        document.getElementById('boss-btn').style.display = 'block';

        // 盤面をリセットして、計算用セット（数字＋演算子）を配る
        this.bubbles = [];
        this.spawnBossBubbles();
    }

    spawnBossBubbles() {
        // 数字と演算子をバランスよく配置
        const ops = ['+', '-', '×'];
        // 必須の演算子を入れる
        let mustOp = '+';
        if (this.bossMission.constraint === 'mul') mustOp = '×';
        if (this.bossMission.constraint === 'sub') mustOp = '-';
        
        this.bubbles.push(this.createBubble(mustOp, 'op')); // 必須演算子
        
        for(let i=0; i<15; i++) {
            if (Math.random() < 0.3) {
                this.bubbles.push(this.createBubble(ops[Math.floor(Math.random()*3)], 'op'));
            } else {
                this.bubbles.push(this.createBubble(Math.floor(Math.random()*9)+1, 'num'));
            }
        }
    }

    // --- ゲームループ処理 ---
    handleInput(e) {
        if (this.state !== 'playing' && this.state !== 'boss') return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // タッチ判定
        for (let i = this.bubbles.length - 1; i >= 0; i--) {
            const b = this.bubbles[i];
            const dist = Math.hypot(b.x - x, b.y - y);
            
            if (dist < b.r) {
                if (this.state === 'playing') {
                    this.checkRule(b, i);
                } else {
                    this.addToFormula(b, i);
                }
                return; // 1回に1個だけ
            }
        }
    }

    // 通常モードの判定ロジック
    checkRule(b, index) {
        let isCorrect = false;
        const val = b.val;

        if (this.currentRule.id === 'odd') {
            isCorrect = (val % 2 !== 0);
        } else if (this.currentRule.id === 'even') {
            isCorrect = (val % 2 === 0);
        } else if (this.currentRule.id === 'asc') {
            // 最初はどれでもOK、2個目以降は「前回より大きい」
            if (this.lastSelectedVal === -1 || val > this.lastSelectedVal) {
                isCorrect = true;
                this.lastSelectedVal = val;
            }
        } else if (this.currentRule.id === 'desc') {
            if (this.lastSelectedVal === -1 || val < this.lastSelectedVal) {
                isCorrect = true;
                this.lastSelectedVal = val;
            }
        }

        if (isCorrect) {
            // 正解！
            this.bubbles.splice(index, 1);
            this.spawnParticles(b.x, b.y, this.currentRule.color);
            this.score += 100 + (this.combo * 10);
            this.combo++;
            this.timeLeft = Math.min(this.maxTime, this.timeLeft + 1); // 時間回復
            
            // 昇順・降順以外は、ある程度消したらルール変更
            // 昇順・降順は「詰む（次の数字がない）」まで継続、または5コンボで変更
            let shouldChange = false;
            if (this.currentRule.id === 'asc' || this.currentRule.id === 'desc') {
                if (this.combo >= 5) shouldChange = true;
            } else {
                if (this.combo % 3 === 0) shouldChange = true;
            }

            if (shouldChange) {
                this.combo = 0; // コンボはスコアにのみ反映し、ルール変更でリセット感
                this.setNextRule();
            }

            // ボス出現判定（ランダム or スコア閾値）
            if (Math.random() < 0.05) { // 5%の確率でボス
                 this.startBossMission();
            }

            // 補充
            if (this.bubbles.length < 5) this.spawnBubbles(5);

        } else {
            // 不正解！
            this.spawnText(b.x, b.y, "MISS!", "#fff");
            this.timeLeft -= 5; // ペナルティ
            this.combo = 0;
            this.lastSelectedVal = -1; // 順序リセット
            
            // 画面を赤くフラッシュ
            document.getElementById('ui-layer').classList.add('damage-flash');
            setTimeout(() => document.getElementById('ui-layer').classList.remove('damage-flash'), 300);
        }
        
        this.updateUI();
    }

    // ボスモードの選択ロジック
    addToFormula(b, index) {
        if (b.selected) return; // 選択済みは無視

        // ルールチェック（数字→記号→数字の順序を守らせる）
        const last = this.bossStack[this.bossStack.length - 1];
        if (!last) {
            if (b.type !== 'num') return; // 最初は数字
        } else {
            if (last.type === 'num' && b.type === 'num') return; // 数字の次は記号
            if (last.type === 'op' && b.type === 'op') return;   // 記号の次は数字
        }

        b.selected = true;
        this.bossStack.push(b);
        this.updateFormulaDisplay();
    }

    updateFormulaDisplay() {
        let str = "";
        this.bossStack.forEach(b => str += b.val + " ");
        document.getElementById('formula-display').innerText = str || this.bossMission.text;
    }

    fireBossShot() {
        if (this.bossStack.length < 3) return;

        // 計算実行
        let exp = "";
        let usedMul = false;
        let usedAdd = false;
        let usedSub = false;

        this.bossStack.forEach(b => {
            let v = b.val;
            if (v === '×') { v = '*'; usedMul = true; }
            if (v === '+') usedAdd = true;
            if (v === '-') usedSub = true;
            exp += v;
        });

        try {
            const result = new Function('return ' + exp)();
            const target = this.bossMission.val;
            const constraint = this.bossMission.constraint;
            
            let constraintMet = false;
            if (constraint === 'mul' && usedMul) constraintMet = true;
            if (constraint === 'add' && usedAdd) constraintMet = true;
            if (constraint === 'sub' && usedSub) constraintMet = true;

            if (result === target && constraintMet) {
                // ボスクリア！
                this.score += 5000;
                this.timeLeft += 10;
                this.spawnText(this.width/2, this.height/2, "MISSION CLEAR!!", "#ff0055", 50);
                
                // 通常モードへ戻る
                this.state = 'playing';
                document.getElementById('boss-btn').style.display = 'none';
                document.getElementById('formula-display').innerText = "";
                this.bubbles = [];
                this.spawnBubbles(12);
                this.setNextRule();

            } else {
                // 失敗
                this.spawnText(this.width/2, this.height/2, "FAILED...", "#888", 40);
                // 選択解除
                this.bossStack.forEach(b => b.selected = false);
                this.bossStack = [];
                this.updateFormulaDisplay();
            }
        } catch(e) {
            // エラー
        }
    }


    // --- 汎用システム ---
    spawnBubbles(count) {
        for (let i = 0; i < count; i++) {
            this.bubbles.push(this.createBubble(Math.floor(Math.random() * 9) + 1, 'num'));
        }
    }

    createBubble(val, type) {
        const r = this.bubbleRadius;
        // 重ならないように配置（簡易版）
        let x, y, ok = false;
        for(let k=0; k<10; k++) {
            x = r + Math.random() * (this.width - r * 2);
            y = this.height * 0.3 + Math.random() * (this.height * 0.5);
            ok = true;
            for(let b of this.bubbles) {
                if (Math.hypot(b.x - x, b.y - y) < r * 2) ok = false;
            }
            if (ok) break;
        }

        return {
            x: x, y: y, r: r,
            val: val, type: type, // 'num' or 'op'
            vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2,
            selected: false,
            color: type === 'num' ? `hsl(${Math.random()*40 + 200}, 80%, 50%)` : '#ff0055'
        };
    }

    spawnParticles(x, y, color) {
        for(let i=0; i<10; i++) {
            this.particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
                life: 1.0, color: color
            });
        }
    }

    spawnText(x, y, text, color, size=30) {
        this.floatingTexts.push({
            x: x, y: y, text: text, color: color, life: 1.0, size: size
        });
    }

    updateUI() {
        document.getElementById('score-val').innerText = this.score;
        document.getElementById('combo-val').innerText = this.combo;
        const pct = (this.timeLeft / this.maxTime) * 100;
        document.getElementById('time-bar').style.width = pct + '%';
        if(pct < 20) document.getElementById('time-bar').style.background = '#ff0000';
        else document.getElementById('time-bar').style.background = '#00ff00';
    }

    loop() {
        // 更新
        if (this.state === 'playing' || this.state === 'boss') {
            this.timeLeft -= 1/60;
            if (this.timeLeft <= 0) {
                this.state = 'gameover';
                document.getElementById('gameover-screen').classList.remove('hidden');
                document.getElementById('final-score').innerText = this.score;
            }
            this.updateUI();
        }

        // バブルの動き
        this.bubbles.forEach(b => {
            b.x += b.vx; b.y += b.vy;
            if (b.x < b.r || b.x > this.width - b.r) b.vx *= -1;
            if (b.y < this.height*0.2 || b.y > this.height - b.r) b.vy *= -1;
        });

        // 描画
        this.ctx.fillStyle = '#050510';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // バブル描画
        this.bubbles.forEach(b => {
            this.ctx.beginPath();
            this.ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
            this.ctx.fillStyle = b.selected ? '#fff' : b.color;
            this.ctx.fill();
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 3;
            this.ctx.stroke();
            
            this.ctx.fillStyle = b.selected ? '#000' : '#fff';
            this.ctx.font = 'bold 30px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(b.val, b.x, b.y);
            
            // 昇順・降順時のリンク線
            if ((this.currentRule && (this.currentRule.id === 'asc' || this.currentRule.id === 'desc')) && 
                this.lastSelectedVal !== -1 && !b.selected) {
                 // ヒント的に、次に押せるやつを少し光らせるなどの演出も可能
            }
        });

        // エフェクト
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 5, 0, Math.PI*2); this.ctx.fill();
            this.ctx.globalAlpha = 1.0;
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
            let t = this.floatingTexts[i];
            t.y -= 1; t.life -= 0.02;
            this.ctx.globalAlpha = t.life;
            this.ctx.fillStyle = t.color;
            this.ctx.font = `bold ${t.size}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(t.text, t.x, t.y);
            this.ctx.globalAlpha = 1.0;
            if (t.life <= 0) this.floatingTexts.splice(i, 1);
        }

        requestAnimationFrame(this.loop);
    }
}

window.game = new Game();

</script>
</body>
</html>
