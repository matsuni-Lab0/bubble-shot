<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Bubble Shot: Shrimp Edition (RUSH + MISSION)</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: 'Helvetica Neue','Arial',sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
    #game-container { position: relative; width: 100vw; height: 100dvh; overflow: hidden; background-color: #050510; }
    canvas { display: block; width: 100%; height: 100%; }

    #ui-layer { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:flex; flex-direction:column; justify-content:space-between; }

    /* --- 上部 --- */
    #top-area {
      height: 180px; display:flex; flex-direction:column; align-items:center; justify-content:flex-start;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0));
      z-index:10; padding-top:10px; box-sizing:border-box; position:relative;
    }

    #commander-window {
      position:absolute; top:10px; left:10px;
      width:70px; height:70px;
      background: rgba(0, 20, 40, 0.6);
      border: 2px solid #00FFFF; border-radius: 10px;
      clip-path: polygon(15% 0, 100% 0, 100% 85%, 85% 100%, 0 100%, 0 15%);
      pointer-events:auto; display:flex; justify-content:center; align-items:center;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
      z-index:25; backdrop-filter: blur(2px);
    }
    #comm-canvas { width:100%; height:100%; }
    #comm-label { position:absolute; bottom:2px; right:4px; font-size:8px; color:#00FFFF; font-family: monospace; opacity:0.8; }

    #manual-shuffle-btn {
      position:absolute; top:15px; left:90px;
      width:40px; height:40px; border-radius:50%;
      background: rgba(255,165,0,0.1); border:2px solid #FFA500;
      color:#FFA500; box-shadow:0 0 10px rgba(255,165,0,0.2); font-size:18px;
      display:flex; justify-content:center; align-items:center;
      pointer-events:auto; cursor:pointer; z-index:20; backdrop-filter: blur(4px);
    }
    #manual-shuffle-btn:active { transform: scale(0.9); }

    #mode-display {
      position:absolute; top:20px; right:15px;
      font-size:12px; font-weight:bold; color:#888; letter-spacing:1px;
      border:1px solid #444; padding:2px 6px; border-radius:4px;
      background: rgba(0,0,0,0.2);
    }

    #time-bar-wrapper { width:55%; height:6px; background:#222; border-radius:4px; margin-top:10px; border:1px solid #555; position:relative; overflow:hidden; }
    #time-bar { width:100%; height:100%; background:#0074D9; transition: width 0.1s linear, background 0.3s; box-shadow:0 0 10px currentColor; }

    #target-label { font-size:10px; color:#00FFFF; letter-spacing:4px; margin-top:5px; opacity:0.8; }
    #target-display {
      font-size:54px; font-weight:900; color:#FFDC00; line-height:1.0; margin:0;
      text-shadow:0 0 20px rgba(255,220,0,0.8); font-family:'Arial Black',sans-serif; letter-spacing:-2px; text-align:center;
    }
    #sub-display {
      margin-top:6px; font-family: monospace; font-size:12px; color:#aaa; text-shadow:0 0 2px #000;
      text-align:center; padding:2px 8px; border:1px solid #333; border-radius:6px;
      max-width:92%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; background: rgba(0,0,0,0.2);
    }

    #status-bar { color:#aaa; font-family: monospace; font-size:16px; display:flex; gap:18px; font-weight:bold; margin-top:6px; text-shadow:0 0 2px #000; }

    /* AUTO LOCK */
    #auto-lock-btn {
      position:absolute; bottom: 100px; right: 20px;
      width: 64px; height: 64px; border-radius: 50%;
      background: rgba(255, 215, 0, 0.18); border: 2px solid #FFD700; color: #FFD700;
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      font-size:10px; font-weight:900; text-align:center;
      box-shadow: 0 0 15px #FFD700; cursor:pointer; pointer-events:auto; z-index:30;
      animation: pulse 2s infinite; line-height:1.1;
    }
    #auto-lock-btn.hidden { display:none !important; }
    .ja-sub { font-size: 8px; font-weight: normal; opacity: 0.8; }
    .trial-badge { position:absolute; top:-5px; right:-5px; background:#FF4136; color:#fff; font-size:8px; padding:2px 4px; border-radius:4px; font-weight:bold; }
    @keyframes pulse { 0% { box-shadow:0 0 0 0 rgba(255,215,0,0.7);} 70% { box-shadow:0 0 0 10px rgba(255,215,0,0);} 100% { box-shadow:0 0 0 0 rgba(255,215,0,0);} }

    /* --- 下部 --- */
    #bottom-area {
      height:190px; display:flex; flex-direction:column; align-items:center; justify-content:flex-end; padding-bottom:28px;
      background: linear-gradient(to top, rgba(0,20,30,0.95) 60%, rgba(0,0,0,0));
      z-index:10;
    }
    #guide-msg {
      color:#00FFFF; font-size:14px; margin-bottom:6px; min-height:42px;
      text-shadow:0 0 5px #00FFFF; letter-spacing:1px; text-align:center; line-height:1.3;
      transition: all 0.3s; padding:0 12px;
    }
    #guide-msg .sub { font-size:10px; color:#aaa; display:block; margin-top:2px; transition: all 0.3s; }
    #formula-bar {
      min-height:30px; margin-bottom:14px; font-size:22px; color:#FFF; font-family: monospace; font-weight:bold;
      text-shadow:0 0 5px #00FFFF, 0 0 10px #00FFFF; white-space:nowrap; max-width:90%; overflow:hidden; text-overflow:ellipsis;
    }
    #btn-group { display:flex; gap:18px; align-items:center; }
    #fire-btn {
      width:150px; height:60px; background: rgba(255,65,54,0.1); border:2px solid #555;
      color:#555; font-size:24px; font-weight:900; letter-spacing:4px; display:flex;
      justify-content:center; align-items:center;
      clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
      transition: all 0.2s; cursor:pointer; pointer-events:none;
    }
    #fire-btn.ready { background: rgba(255,65,54,0.85); border:none; color:white; box-shadow:0 0 30px #FF4136; pointer-events:auto; transform: scale(1.05); text-shadow:0 0 10px white; }
    #fire-btn:active { transform: scale(0.95); background:#fff; color:#FF4136; }
    #clear-btn {
      width:50px; height:50px; border-radius:50%; border:1px solid #00FFFF; color:#00FFFF;
      display:flex; justify-content:center; align-items:center; font-size:10px; cursor:pointer;
      background: rgba(0,255,255,0.05); pointer-events:auto; box-shadow:0 0 5px rgba(0,255,255,0.2);
    }

    /* --- 画面 --- */
    #menu-screen, #gameover-screen {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background: rgba(5,10,15,0.95);
      display:flex; flex-direction:column; justify-content:flex-start; align-items:center;
      pointer-events:auto; z-index:50; text-align:center; box-sizing:border-box; padding:40px 20px; overflow-y:auto;
    }
    #menu-screen { justify-content:center; }
    h1 { color:#00FFFF; font-size:34px; font-weight:900; text-shadow:0 0 10px #00FFFF, 0 0 30px #00FFFF; margin:10px 0; letter-spacing:4px; font-style: italic; font-family:'Arial Black',sans-serif; }
    .btn {
      padding:14px 26px; font-size:16px; background: transparent; border:2px solid #FFDC00;
      color:#FFDC00; cursor:pointer; font-weight:bold;
      box-shadow:0 0 10px #FFDC00, inset 0 0 10px #FFDC00;
      transition: all 0.2s; margin-top:12px; text-transform: uppercase; letter-spacing:2px;
      width:100%; max-width:340px;
    }
    .btn:hover { background:#FFDC00; color:#000; box-shadow:0 0 30px #FFDC00; }
    .btn-blue { border-color:#00FFFF; color:#00FFFF; box-shadow:0 0 8px #00FFFF, inset 0 0 8px #00FFFF; }
    .btn-blue:hover { background:#00FFFF; color:#000; box-shadow:0 0 28px #00FFFF; }
    .btn-red { border-color:#FF4136; color:#FF4136; box-shadow:0 0 8px #FF4136, inset 0 0 8px #FF4136; }
    .btn-red:hover { background:#FF4136; color:#000; box-shadow:0 0 28px #FF4136; }
    .btn-link { border-color:#AAAAAA; color:#AAAAAA; box-shadow:none; border-style:dashed; font-size:12px; }
    .btn-link:hover { background:#555; color:#fff; }

    .rule-box { font-size:13px; color:#ccc; line-height:1.6; margin-bottom:18px; text-align:left; display:inline-block; max-width:360px; }
    .rule-box .en { color:#fff; font-weight:bold; display:block; margin-bottom:2px; }
    .rule-box .ja { color:#888; font-size:11px; display:block; margin-bottom:10px; }

    .hidden { display:none !important; }

    #mascot-canvas-menu, #mascot-canvas-over { width:100px; height:100px; margin-bottom:10px; }

    #rank-list-container { width:100%; max-width:360px; margin-bottom:20px; text-align:left; border-top:1px solid #333; margin-top:16px; }
    .rank-item { display:flex; justify-content:space-between; align-items:center; padding:8px 6px; border-bottom:1px solid #222; font-family: monospace; }
    .rank-item.active { color:#FFDC00; background: linear-gradient(90deg, transparent, rgba(255,220,0,0.12), transparent); font-weight:bold; text-shadow:0 0 5px #FFDC00; }
    .rank-name-col { flex-grow:1; padding-left:10px; display:flex; flex-direction:column; }
    .rank-name-en { font-size:14px; color:#ccc; }
    .rank-name-ja { font-size:10px; color:#666; }
    .active .rank-name-en { color:#FFDC00; }
    .active .rank-name-ja { color:#AA8800; }
    .rank-score { width:70px; text-align:right; font-size:14px; color:#888; }
    .rank-arrow { width:52px; color:#FF4136; text-align:right; font-weight:bold; font-size:12px; animation: blink 0.5s infinite alternate; }
    @keyframes blink { from { opacity:1; } to { opacity:0.3; } }
  </style>
</head>

<body>
<div id="game-container">
  <canvas id="gameCanvas"></canvas>

  <div id="ui-layer">
    <div id="top-area">
      <div id="commander-window">
        <canvas id="comm-canvas" width="70" height="70"></canvas>
        <div id="comm-label">CMD</div>
      </div>
      <div id="manual-shuffle-btn" onclick="game.manualShuffle()">↻</div>
      <div id="mode-display">MODE: MENU</div>

      <div id="time-bar-wrapper"><div id="time-bar"></div></div>
      <div id="target-label">TARGET</div>
      <div id="target-display">??</div>
      <div id="sub-display">—</div>

      <div id="status-bar">
        <span id="score-display">SCORE: 0</span>
        <span id="timer-display">TIME: 0</span>
        <span id="combo-display">COMBO: 0</span>
      </div>
    </div>

    <div style="flex-grow: 1;"></div>

    <!-- ★RUSH/MISSION 共通で表示する（プレイ中のみ） -->
    <div id="auto-lock-btn" onclick="game.autoLock()">
      <div class="trial-badge">FREE</div>
      <span id="auto-lock-title">AUTO<br>LOCK</span>
      <span class="ja-sub" id="auto-lock-sub">自動ロック</span>
    </div>

    <div id="bottom-area">
      <div id="guide-msg">
        LOCK: [NUM]
        <span class="sub">数字をロックせよ</span>
      </div>
      <div id="formula-bar">READY...</div>
      <div id="btn-group">
        <div id="clear-btn" onclick="game.clearFormula()">CLR</div>
        <div id="fire-btn" onclick="game.fire()">FIRE</div>
      </div>
    </div>
  </div>

  <div id="menu-screen">
    <canvas id="mascot-canvas-menu" width="100" height="100"></canvas>
    <h1>BUBBLE SHOT</h1>
    <p style="color:#00FFFF; font-size:12px; margin-bottom: 18px; font-family: monospace;">
      SYSTEM: ONLINE<br>MODE: HI-MAT LOCKON
    </p>

    <div class="rule-box">
      <span class="en">RUSH MODE (Main)</span>
      <span class="ja">奇数/偶数/昇順/降順の「ロックオン・ラッシュ」。AUTO LOCK対応。</span>
      <span class="en">MISSION MODE (Sub)</span>
      <span class="ja">ターゲット数字を「指示つき（×のみ等）」で作る。AUTO LOCKで解ける式を自動ロック。</span>
    </div>

    <button class="btn btn-blue" onclick="game.startRush('normal')">START: RUSH (NORMAL)<br><span style="font-size:11px">20秒 / 0-30</span></button>
    <button class="btn btn-blue" onclick="game.startRush('hard')">START: RUSH (HARD)<br><span style="font-size:11px">20秒 / 0-50</span></button>

    <button class="btn btn-red" onclick="game.startMission('normal')">START: MISSION (NORMAL)<br><span style="font-size:11px">90秒 / 0-30</span></button>
    <button class="btn btn-red" onclick="game.startMission('hard')">START: MISSION (HARD)<br><span style="font-size:11px">90秒 / 0-50</span></button>

    <div style="margin-top: 10px; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px;">
      <button class="btn btn-link" onclick="alert('Coming Soon!\\n準備中です。')">LINE STICKERS (Coming Soon)</button>
      <button class="btn btn-link" onclick="alert('Coming Soon!\\n準備中です。')">ROBLOX (Coming Soon)</button>
    </div>
  </div>

  <div id="gameover-screen" class="hidden">
    <canvas id="mascot-canvas-over" width="100" height="100"></canvas>
    <h1 id="result-title">MISSION OVER</h1>
    <p id="result-final" style="font-size:36px; color:#FFDC00; margin: 6px 0; font-family:'Arial Black',sans-serif;">0</p>
    <div id="rank-list-container"></div>
    <button class="btn" onclick="location.reload()">Return to Menu</button>
  </div>
</div>

<script>
/** =========================
 * 設定
 * ========================= */
const OPS = {
  add: { label: '+', op: '+' },
  sub: { label: '-', op: '-' },
  mul: { label: '×', op: '*' },
  div: { label: '÷', op: '/' }
};

const RUSH_TYPES = [
  { id: 'odd',  labelEn: 'ODD NUMBERS',  labelJa: '奇数を撃て',  ui: 'ODD'  },
  { id: 'even', labelEn: 'EVEN NUMBERS', labelJa: '偶数を撃て',  ui: 'EVEN' },
  { id: 'asc',  labelEn: 'ASCENDING',    labelJa: '昇順で撃て（小→大）', ui: 'ASC'  },
  { id: 'desc', labelEn: 'DESCENDING',   labelJa: '降順で撃て（大→小）', ui: 'DESC' }
];

const MISSION_RULES = [
  { id: 'mul_only',  label: '×のみで作れ',           allowedOps: ['mul'], requireOp: null, requireNums: 0, noRepeat: false },
  { id: 'add_only',  label: '＋のみで作れ',           allowedOps: ['add'], requireOp: null, requireNums: 0, noRepeat: false },
  { id: 'no_div',    label: '÷は禁止',               allowedOps: ['add','sub','mul'], requireOp: null, requireNums: 0, noRepeat: false },
  { id: 'need_div',  label: '÷を必ず1回使え',        allowedOps: ['add','sub','mul','div'], requireOp: 'div', requireNums: 0, noRepeat: false },
  { id: 'need_3num', label: '数字を3つ使え',          allowedOps: ['add','sub','mul','div'], requireOp: null, requireNums: 3, noRepeat: false },
  { id: 'no_repeat', label: '同じ数字は禁止',         allowedOps: ['add','sub','mul','div'], requireOp: null, requireNums: 0, noRepeat: true }
];

const RANKS = [
  { min: 50000, nameEn: "WHITE SHRIMP",   nameJa: "シロエビ" },
  { min: 35000, nameEn: "ISE LOBSTER",    nameJa: "伊勢海老" },
  { min: 20000, nameEn: "WILD PRAWN",     nameJa: "クルマエビ(天然)" },
  { min: 12000, nameEn: "BOTAN SHRIMP",   nameJa: "ボタンエビ" },
  { min: 6000,  nameEn: "SWEET SHRIMP",   nameJa: "アマエビ" },
  { min: 2000,  nameEn: "BLACK TIGER",    nameJa: "ブラックタイガー" },
  { min: 0,     nameEn: "SAKURA SHRIMP",  nameJa: "サクラエビ" }
];

/** =========================
 * ユーティリティ
 * ========================= */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function randInt(a, b){ return Math.floor(Math.random() * (b - a + 1)) + a; }
function shuffle(arr){
  for(let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function opSymbol(opKey){ return OPS[opKey]?.label ?? '?'; }
function opExec(opKey, a, b){
  if(opKey === 'add') return a + b;
  if(opKey === 'sub') return a - b;
  if(opKey === 'mul') return a * b;
  if(opKey === 'div'){
    if(b === 0) return null;
    if(a % b !== 0) return null;
    return a / b;
  }
  return null;
}

/** =========================
 * ゲーム本体
 * ========================= */
class Game {
  constructor(){
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');

    this.commCanvas = document.getElementById('comm-canvas');
    this.commCtx = this.commCanvas.getContext('2d');

    // レイアウト
    this.width = 0; this.height = 0; this.dpr = 1;
    this.centerX = 0; this.centerY = 0; this.radarRadius = 0;

    // 状態
    this.state = 'menu';
    this.mode = 'menu';
    this.difficulty = 'normal';
    this.maxNum = 30;

    // タイマー
    this.rushMaxTime = 20;
    this.missionMaxTime = 90;
    this.timeLeft = 0;

    // スコア/コンボ
    this.score = 0;
    this.combo = 0;
    this.bestCombo = 0;

    // ボード
    this.entities = [];
    this.formulaStack = [];

    // ラッシュ
    this.rushType = null;
    this.rushExpected = null;

    // ミッション
    this.targetNum = 0;
    this.missionRule = null;

    // 演出
    this.effects = [];
    this.scanAngle = 0;
    this.bgScroll = 0;
    this.lastTime = 0;

    // ★ロックオン演出（司令→ターゲット）
    this.lockAim = null; // {x,y,life,alpha}
    this.lockFrom = { x: 45, y: 45 }; // 司令窓の概算位置
    this.autoBusy = false;

    setTimeout(() => this.resize(), 60);
    window.addEventListener('resize', () => this.resize());

    this.drawStaticMascot('mascot-canvas-menu', 'normal');
    this.drawStaticMascot('mascot-canvas-over', 'panic');
    this.updateCommander('normal');

    this.canvas.addEventListener('pointerdown', (e) => this.handleClick(e));

    this.loop = this.loop.bind(this);
    requestAnimationFrame(this.loop);

    this.updateUI();
    this.showMenu();
  }

  /* ---------- UI ---------- */
  setModeLabel(text){ document.getElementById('mode-display').innerText = text; }
  setTarget(label, value){ document.getElementById('target-label').innerText = label; document.getElementById('target-display').innerText = value; }
  setSub(text){ document.getElementById('sub-display').innerText = text; }
  setGuide(main, sub, color){
    const msg = document.getElementById('guide-msg');
    msg.innerHTML = `${main}<span class="sub">${sub}</span>`;
    msg.style.color = color || "#00FFFF";
  }
  setFormulaText(text, color){
    const bar = document.getElementById('formula-bar');
    bar.innerText = text;
    bar.style.color = color || "#00FFFF";
  }
  setAutoLockVisible(isVisible){
    const btn = document.getElementById('auto-lock-btn');
    if(isVisible) btn.classList.remove('hidden');
    else btn.classList.add('hidden');
  }
  setAutoLockLabel(mode){
    const title = document.getElementById('auto-lock-title');
    const sub = document.getElementById('auto-lock-sub');
    if(mode === 'rush'){
      title.innerHTML = "AUTO<br>LOCK";
      sub.textContent = "連続ロック";
    } else if(mode === 'mission'){
      title.innerHTML = "AUTO<br>LOCK";
      sub.textContent = "式を自動";
    } else {
      title.innerHTML = "AUTO<br>LOCK";
      sub.textContent = "—";
    }
  }

  updateUI(){
    document.getElementById('score-display').innerText = `SCORE: ${this.score}`;
    document.getElementById('timer-display').innerText = `TIME: ${Math.max(0, Math.floor(this.timeLeft))}`;
    document.getElementById('combo-display').innerText = `COMBO: ${this.combo}`;
    this.updateTimeBar();
  }
  updateTimeBar(){
    const bar = document.getElementById('time-bar');
    const maxT = (this.mode === 'rush') ? this.rushMaxTime : this.missionMaxTime;
    const pct = (maxT <= 0) ? 0 : clamp((this.timeLeft / maxT) * 100, 0, 100);
    bar.style.width = `${pct}%`;
    if (pct < 20) bar.style.backgroundColor = '#FF4136';
    else if (pct < 50) bar.style.backgroundColor = '#FFDC00';
    else bar.style.backgroundColor = '#0074D9';
  }

  showMenu(){
    this.state = 'menu';
    this.mode = 'menu';
    this.setModeLabel('MODE: MENU');
    this.setTarget('TARGET', '??');
    this.setSub('—');
    this.setGuide('LOCK: [NUM]', '数字をロックせよ', '#00FFFF');
    this.setFormulaText('READY...', '#666');
    this.setAutoLockVisible(false);
    this.setAutoLockLabel('menu');

    document.getElementById('menu-screen').classList.remove('hidden');
    document.getElementById('gameover-screen').classList.add('hidden');
  }

  /* ---------- リサイズ ---------- */
  resize(){
    this.dpr = window.devicePixelRatio || 1;
    this.width = window.innerWidth;
    this.height = window.innerHeight;

    this.canvas.width = Math.floor(this.width * this.dpr);
    this.canvas.height = Math.floor(this.height * this.dpr);
    this.canvas.style.width = this.width + 'px';
    this.canvas.style.height = this.height + 'px';
    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

    const topSpace = 180;
    const bottomSpace = 190;
    this.centerY = topSpace + (this.height - topSpace - bottomSpace) / 2;
    this.centerX = this.width / 2;
    const maxRadius = Math.min(this.width, (this.height - topSpace - bottomSpace)) / 2;
    this.radarRadius = Math.max(0, maxRadius - 10);
  }

  /* ---------- 開始 ---------- */
  startRush(diff){
    this.state = 'rush';
    this.mode = 'rush';
    this.difficulty = diff;
    this.maxNum = (diff === 'hard') ? 50 : 30;

    this.score = 0; this.combo = 0; this.bestCombo = 0;
    this.timeLeft = this.rushMaxTime;

    this.entities = []; this.formulaStack = []; this.effects = [];
    this.autoBusy = false;

    this.setModeLabel(`MODE: RUSH / ${diff.toUpperCase()} (0-${this.maxNum})`);
    this.setAutoLockVisible(true);      // ★RUSHでも表示
    this.setAutoLockLabel('rush');      // ★RUSH用ラベル
    this.setFormulaText('RUSH MODE', '#00FFFF');

    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('gameover-screen').classList.add('hidden');

    this.updateCommander('normal');
    this.startRushRound(true);
    this.updateUI();
  }

  startMission(diff){
    this.state = 'mission';
    this.mode = 'mission';
    this.difficulty = diff;
    this.maxNum = (diff === 'hard') ? 50 : 30;

    this.score = 0; this.combo = 0; this.bestCombo = 0;
    this.timeLeft = this.missionMaxTime;

    this.entities = []; this.formulaStack = []; this.effects = [];
    this.autoBusy = false;

    this.setModeLabel(`MODE: MISSION / ${diff.toUpperCase()} (0-${this.maxNum})`);
    this.setAutoLockVisible(true);
    this.setAutoLockLabel('mission');

    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('gameover-screen').classList.add('hidden');

    this.updateCommander('normal');

    this.replenishMissionEntities(true);
    this.generateMission(true);
    this.clearFormula();
    this.updateUI();
  }

  /* =========================================================
   * ロックオン演出（司令→ターゲット）
   * ========================================================= */
  setLockAim(x, y){
    this.lockAim = { x, y, life: 22, alpha: 1.0 };
  }

  /* =========================================================
   * RUSH MODE
   * ========================================================= */
  startRushRound(isFirst=false){
    this.rushType = RUSH_TYPES[randInt(0, RUSH_TYPES.length - 1)];
    this.combo = 0;
    this.rushExpected = null;

    this.entities = [];

    const count = (this.width < 400) ? 22 : (this.width > 800 ? 36 : 28);
    const r = Math.max(16, Math.min(24, Math.min(this.width, this.height) / 16));

    if(this.rushType.id === 'asc' || this.rushType.id === 'desc'){
      const pool = [];
      for(let i=0; i<=this.maxNum; i++) pool.push(i);
      shuffle(pool);
      const chosen = pool.slice(0, Math.min(count, pool.length));
      this.rushExpected = (this.rushType.id === 'asc') ? Math.min(...chosen) : Math.max(...chosen);
      for(let n of chosen) this.spawnEntityNum(n, r);
    } else {
      for(let i=0; i<count; i++) this.spawnEntityNum(randInt(0, this.maxNum), r);
    }

    this.setTarget('MODE', this.rushType.ui);
    if(this.rushType.id === 'asc' || this.rushType.id === 'desc'){
      this.setSub(`${this.rushType.labelEn} / NEXT: ${this.rushExpected}`);
    } else {
      this.setSub(`${this.rushType.labelEn} / ${this.rushType.labelJa}`);
    }
    this.setGuide(
      `${this.rushType.labelEn}`,
      `${this.rushType.labelJa}（AUTO LOCKで連続ロック）`,
      '#FFDC00'
    );

    this.addEffect({ text: isFirst ? 'RUSH START' : 'NEXT RULE', color: '#00FFFF', size: 24 });
  }

  spawnEntityNum(value, r){
    let x, y, safe=false, tries=0;
    const maxAttempts=140;
    while(!safe && tries < maxAttempts){
      tries++;
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.sqrt(Math.random()) * (this.radarRadius - r - 5);
      x = this.centerX + Math.cos(angle) * dist;
      y = this.centerY + Math.sin(angle) * dist;

      safe=true;
      for(const e of this.entities){
        if(Math.hypot(e.x-x, e.y-y) < r*2.05){ safe=false; break; }
      }
    }
    if(!safe) return;
    this.entities.push({ type:'num', val:value, x, y, r, selected:false, order:null, scale:0 });
  }

  rushIsValidHit(ent){
    if(ent.type !== 'num') return false;
    const v = ent.val;
    if(this.rushType.id === 'odd') return (v % 2 !== 0);
    if(this.rushType.id === 'even') return (v % 2 === 0);
    if(this.rushType.id === 'asc') return (v === this.rushExpected);
    if(this.rushType.id === 'desc') return (v === this.rushExpected);
    return false;
  }

  rushOnHit(entRef){
    // entRefは参照。今の配列内インデックスを取り直す
    const idx = this.entities.indexOf(entRef);
    if(idx < 0) return;

    this.combo++;
    this.bestCombo = Math.max(this.bestCombo, this.combo);

    let base = 120;
    if(this.rushType.id === 'asc' || this.rushType.id === 'desc') base = 160;
    const mult = 1 + Math.min(2.0, this.combo * 0.06);
    const add = Math.floor(base * mult);
    this.score += add;

    this.addEffect({ text: `LOCK +${add}`, x: entRef.x, y: entRef.y - 25, color: '#FFDC00', size: 18, life: 40 });
    this.updateCommander('happy');

    this.entities.splice(idx, 1);

    if(this.rushType.id === 'asc' || this.rushType.id === 'desc'){
      const remainVals = this.entities.map(e => e.val);
      if(remainVals.length === 0){
        this.startRushRound(false);
      }else{
        this.rushExpected = (this.rushType.id === 'asc') ? Math.min(...remainVals) : Math.max(...remainVals);
        this.setSub(`${this.rushType.labelEn} / NEXT: ${this.rushExpected}`);
      }
    } else {
      if(this.entities.length < 14){
        const r = Math.max(16, Math.min(24, Math.min(this.width, this.height) / 16));
        for(let i=0; i<10; i++) this.spawnEntityNum(randInt(0, this.maxNum), r);
      }
    }

    this.updateUI();
    setTimeout(() => { if(this.state === 'rush') this.updateCommander('normal'); }, 220);
  }

  rushOnMiss(ent){
    this.addEffect({ text:'MISS', x: ent.x, y: ent.y, color:'#888', size: 24, life: 35 });
    this.combo = 0;
    this.updateCommander('panic');
    this.updateUI();
    setTimeout(() => { if(this.state === 'rush') this.updateCommander('normal'); }, 380);
  }

  /* =========================================================
   * MISSION MODE
   * ========================================================= */
  generateMission(isFirst=false){
    this.targetNum = randInt(0, this.maxNum);

    const pick = Math.random();
    let rule;
    if(pick < 0.35){
      rule = (Math.random() < 0.5) ? MISSION_RULES.find(r=>r.id==='mul_only') : MISSION_RULES.find(r=>r.id==='add_only');
    } else {
      rule = MISSION_RULES[randInt(0, MISSION_RULES.length - 1)];
    }
    this.missionRule = rule;

    this.setTarget('TARGET', String(this.targetNum));
    this.setSub(`MISSION: ${rule.label}`);
    this.setGuide(`TARGET: ${this.targetNum}`, `指示：${rule.label} / AUTO LOCKで自動ロック`, '#FFDC00');

    this.addEffect({ text: isFirst ? 'MISSION START' : 'NEXT TARGET', color: '#00FFFF', size: 24 });
  }

  replenishMissionEntities(reset=false){
    if(reset) this.entities = [];
    const targetCount = (this.width < 400) ? 24 : (this.width > 800 ? 38 : 30);
    const r = Math.max(16, Math.min(24, Math.min(this.width, this.height) / 16));
    while(this.entities.length < targetCount) this.spawnMissionEntity(r);
  }

  spawnMissionEntity(r){
    let x, y, safe=false, tries=0;
    const maxAttempts=140;
    while(!safe && tries < maxAttempts){
      tries++;
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.sqrt(Math.random()) * (this.radarRadius - r - 5);
      x = this.centerX + Math.cos(angle) * dist;
      y = this.centerY + Math.sin(angle) * dist;

      safe=true;
      for(const e of this.entities){
        if(Math.hypot(e.x-x, e.y-y) < r*2.05){ safe=false; break; }
      }
    }
    if(!safe) return;

    const ent = { type: (Math.random() < 0.55 ? 'num' : 'op'), val: 0, x, y, r, selected:false, order:null, scale:0 };
    if(ent.type === 'num') ent.val = randInt(0, this.maxNum);
    else {
      const keys = Object.keys(OPS);
      ent.val = keys[randInt(0, keys.length - 1)];
    }
    this.entities.push(ent);
  }

  clearFormula(){
    this.entities.forEach(e => { e.selected=false; e.order=null; });
    this.formulaStack = [];
    this.updateFormulaBar();
    this.updateGuideByMode();
    this.checkFireReady();
  }

  allowedOpsText(){
    const r = this.missionRule;
    if(!r) return '—';
    return r.allowedOps.map(k => opSymbol(k)).join(' ');
  }

  updateGuideByMode(){
    if(this.mode === 'rush'){
      if(!this.rushType) return;
      this.setGuide(`${this.rushType.labelEn}`, `${this.rushType.labelJa}（AUTO LOCKで連続ロック）`, '#FFDC00');
      return;
    }
    const msg = document.getElementById('guide-msg');
    if (this.formulaStack.length === 0) {
      msg.innerHTML = `LOCK: [NUMBER]<span class="sub">数字をロックせよ（${this.missionRule?.label ?? '—'}）</span>`;
      msg.style.color = "#FFDC00";
    } else {
      const last = this.formulaStack[this.formulaStack.length - 1].entity;
      if (last.type === 'num') {
        msg.innerHTML = `LOCK: [SYMBOL]<span class="sub">記号をロックせよ（許可：${this.allowedOpsText()}）</span>`;
        msg.style.color = "#2ECC40";
      } else {
        msg.innerHTML = `LOCK: [NUMBER]<span class="sub">数字をロックせよ（ターゲット：${this.targetNum}）</span>`;
        msg.style.color = "#FFDC00";
      }
    }
  }

  updateFormulaBar(){
    const bar = document.getElementById('formula-bar');
    if (this.mode !== 'mission'){
      bar.innerText = 'RUSH MODE';
      bar.style.color = "#00FFFF";
      return;
    }
    if (this.formulaStack.length === 0) { bar.innerText = "STANDBY..."; bar.style.color = "#666"; return; }

    let displayStr = `${this.formulaStack[0].entity.val}`;
    for (let i = 1; i < this.formulaStack.length; i += 2) {
      const opEnt = this.formulaStack[i].entity;
      const opStr = opSymbol(opEnt.val);
      if (i + 1 < this.formulaStack.length) {
        const numEnt = this.formulaStack[i+1].entity;
        displayStr = `${displayStr} ${opStr} ${numEnt.val}`;
      } else displayStr = `${displayStr} ${opStr} ?`;
    }
    bar.innerText = displayStr;
    bar.style.color = "#00FFFF";
  }

  checkFireReady(){
    const btn = document.getElementById('fire-btn');
    if(this.mode !== 'mission'){
      btn.classList.remove('ready');
      btn.style.pointerEvents = 'none';
      return;
    }
    const len = this.formulaStack.length;
    if (len >= 1 && this.formulaStack[len-1].entity.type === 'num') btn.classList.add('ready');
    else btn.classList.remove('ready');
  }

  trySelectMission(ent){
    if (ent.selected) return;
    const lastItem = this.formulaStack[this.formulaStack.length - 1];

    if (!lastItem) {
      if (ent.type !== 'num') { this.addEffect({text: "Select NUMBER!", x: ent.x, y: ent.y, color:'#FF4136', size:16}); return; }
    } else {
      if (lastItem.entity.type === 'num' && ent.type === 'num') { this.addEffect({text: "Select SYMBOL!", x: ent.x, y: ent.y, color:'#FF4136', size:16}); return; }
      if (lastItem.entity.type === 'op' && ent.type === 'op') { this.addEffect({text: "Select NUMBER!", x: ent.x, y: ent.y, color:'#FF4136', size:16}); return; }

      if(ent.type === 'op'){
        if(this.missionRule && !this.missionRule.allowedOps.includes(ent.val)){
          this.addEffect({text: "OP NOT ALLOWED", x: ent.x, y: ent.y, color:'#FF4136', size:14});
          return;
        }
      }
      if(ent.type === 'num' && this.missionRule?.noRepeat){
        const usedNums = this.formulaStack.filter(x => x.entity.type === 'num').map(x => x.entity.val);
        if(usedNums.includes(ent.val)){
          this.addEffect({text: "NO REPEAT", x: ent.x, y: ent.y, color:'#FF4136', size:14});
          return;
        }
      }
    }

    // ★ターゲットを選択していく演出
    this.setLockAim(ent.x, ent.y);

    ent.selected = true;
    ent.order = this.formulaStack.length + 1;
    this.formulaStack.push({ entity: ent, time: Date.now() });

    this.addEffect({text:'LOCK', x: ent.x, y: ent.y - 28, color:'#00FFFF', life:12, size:12});
    this.updateFormulaBar();
    this.updateGuideByMode();
    this.checkFireReady();
  }

  fire(){
    if (this.state !== 'mission') return;
    if (this.formulaStack.length === 0) return;
    if (this.formulaStack[this.formulaStack.length-1].entity.type === 'op') {
      this.addEffect({text: "Finish with NUMBER!", color:'#FF4136', size:18});
      return;
    }

    const usedOps = [];
    const usedNums = [];
    for(const s of this.formulaStack){
      if(s.entity.type === 'op') usedOps.push(s.entity.val);
      if(s.entity.type === 'num') usedNums.push(s.entity.val);
    }

    if(this.missionRule?.requireNums && usedNums.length < this.missionRule.requireNums){
      this.addEffect({text: "NEED 3 NUMBERS", color:'#FF4136', size:18});
      this.updateCommander('panic'); setTimeout(()=>this.updateCommander('normal'), 450);
      return this.resetFormulaAfterAttempt(false);
    }

    if(this.missionRule?.requireOp){
      if(!usedOps.includes(this.missionRule.requireOp)){
        this.addEffect({text: "DIV REQUIRED", color:'#FF4136', size:18});
        this.updateCommander('panic'); setTimeout(()=>this.updateCommander('normal'), 450);
        return this.resetFormulaAfterAttempt(false);
      }
    }

    let result = this.formulaStack[0].entity.val;
    let scoreBonus = 0;
    let valid = true;

    for (let i = 1; i < this.formulaStack.length; i += 2) {
      const opKey = this.formulaStack[i].entity.val;
      const num = this.formulaStack[i+1].entity.val;

      const res = opExec(opKey, result, num);
      if (res === null) { valid = false; break; }
      result = res;

      if (opKey === 'mul') scoreBonus += 240;
      if (opKey === 'div') scoreBonus += 520;
      if (opKey === 'sub') scoreBonus += 120;
      if (opKey === 'add') scoreBonus += 100;
    }

    if (valid && result === this.targetNum) {
      const len = this.formulaStack.length;
      let multiplier = 1.0;
      if (len >= 5) multiplier = 1.35;
      if (len >= 7) multiplier = 1.8;

      const baseScore = len * 120;
      const totalScore = Math.floor((baseScore + scoreBonus) * multiplier);

      this.score += totalScore;
      this.combo++;
      this.bestCombo = Math.max(this.bestCombo, this.combo);

      this.addEffect({text: `HIT!! +${totalScore}`, color:'#FFDC00', size:34});
      this.updateCommander('happy');

      this.entities = this.entities.filter(e => !e.selected);
      this.replenishMissionEntities(false);

      this.generateMission(false);
      setTimeout(() => { if(this.state === 'mission') this.updateCommander('normal'); }, 320);
      this.resetFormulaAfterAttempt(true);
    } else {
      const disp = valid ? Math.round(result) : "INVALID";
      this.addEffect({text: `MISS (${disp})`, color:'#888', size:26});
      this.combo = 0;
      this.updateCommander('panic');
      setTimeout(() => { if(this.state === 'mission') this.updateCommander('normal'); }, 450);
      this.resetFormulaAfterAttempt(false);
    }

    this.updateUI();
  }

  resetFormulaAfterAttempt(){
    this.entities.forEach(e => { e.selected=false; e.order=null; });
    this.formulaStack = [];
    this.updateFormulaBar();
    this.updateGuideByMode();
    this.checkFireReady();
  }

  manualShuffle(){
    if(this.state !== 'rush' && this.state !== 'mission') return;

    this.addEffect({text: "RESHUFFLE!", color:"#FFA500", size:26});
    this.updateCommander('panic');

    if(this.mode === 'rush'){
      this.startRushRound(false);
    } else {
      this.entities = [];
      this.clearFormula();
      this.replenishMissionEntities(true);
      this.generateMission(false);
    }

    setTimeout(()=> { if(this.state === 'rush' || this.state === 'mission') this.updateCommander('normal'); }, 350);
  }

  /* =========================================================
   * AUTO LOCK（RUSH + MISSION 両対応）
   * ========================================================= */
  autoLock(){
    if(this.autoBusy) return;
    if(this.state !== 'rush' && this.state !== 'mission') return;

    if(this.state === 'rush') this.autoLockRush();
    else this.autoLockMission();
  }

  autoLockRush(){
    this.autoBusy = true;
    this.addEffect({text:"AUTO LOCK!!", color:"#FFD700", size:30});
    this.updateCommander('happy');

    // どれをロックするかリスト化
    const seq = [];

    if(this.rushType.id === 'asc' || this.rushType.id === 'desc'){
      // 昇順/降順：今の期待値を順に拾う
      // ただし無限にならないよう最大8個まで
      for(let t=0; t<8; t++){
        const target = this.entities.find(e => e.type==='num' && e.val===this.rushExpected);
        if(!target) break;
        seq.push(target);

        // 1個消す前提で次期待値を計算するため、擬似的に候補を作る
        const remainVals = this.entities
          .filter(e => e !== target)
          .map(e => e.val);
        if(remainVals.length === 0) break;
        this.rushExpected = (this.rushType.id === 'asc') ? Math.min(...remainVals) : Math.max(...remainVals);
      }
    } else {
      // odd/even：条件一致を最大10個
      const candidates = this.entities.filter(e => this.rushIsValidHit(e));
      shuffle(candidates);
      candidates.slice(0, 10).forEach(e => seq.push(e));
    }

    let delay = 0;
    seq.forEach((ent) => {
      setTimeout(() => {
        if(this.state !== 'rush') return;
        if(!this.entities.includes(ent)) return;

        // ★ターゲットを選択していく演出
        this.setLockAim(ent.x, ent.y);
        this.rushOnHit(ent);
      }, delay);
      delay += 120;
    });

    setTimeout(()=> {
      this.autoBusy = false;
      if(this.state === 'rush') this.updateCommander('normal');
    }, delay + 200);
  }

  autoLockMission(){
    this.autoBusy = true;

    this.clearFormula();
    const solution = this.findSolutionMission3Steps();
    if(!solution){
      this.addEffect({text:"NO SOLUTION... RESHUFFLE", color:'#FF4136', size:18});
      this.autoBusy = false;
      this.manualShuffle();
      return;
    }

    this.updateCommander('happy');
    this.addEffect({text:"AUTO LOCK!!", color:'#FFD700', size:30});

    let delay = 0;
    solution.forEach(ent => {
      setTimeout(() => {
        if(this.state !== 'mission') return;

        // ★ターゲットを選択していく演出
        this.setLockAim(ent.x, ent.y);

        this.trySelectMission(ent);
      }, delay);
      delay += 90;
    });

    setTimeout(()=> {
      this.autoBusy = false;
      if(this.state === 'mission') this.updateCommander('normal');
    }, delay + 200);
  }

  findSolutionMission3Steps(){
    const nums = this.entities.filter(e => e.type === 'num');
    const ops = this.entities.filter(e => e.type === 'op');

    const rule = this.missionRule || MISSION_RULES[0];
    const opList = rule.allowedOps.slice();

    for(const n1 of nums){
      if(n1.val === this.targetNum){
        if(rule.requireNums && rule.requireNums > 1) continue;
        if(rule.requireOp) continue;
        return [n1];
      }
    }

    for(let i=0; i<nums.length; i++){
      for(let j=0; j<nums.length; j++){
        if(i===j) continue;
        const a = nums[i], b = nums[j];
        if(rule.noRepeat && a.val === b.val) continue;

        for(const opKey of opList){
          const opEnt = ops.find(o => o.val === opKey);
          if(!opEnt) continue;
          const r = opExec(opKey, a.val, b.val);
          if(r === null) continue;
          if(r === this.targetNum){
            if(rule.requireNums && rule.requireNums > 2) continue;
            if(rule.requireOp && ![opKey].includes(rule.requireOp)) continue;
            return [a, opEnt, b];
          }
        }
      }
    }

    for(let i=0; i<nums.length; i++){
      for(let j=0; j<nums.length; j++){
        if(i===j) continue;
        for(let k=0; k<nums.length; k++){
          if(k===i || k===j) continue;

          const a = nums[i], b = nums[j], c = nums[k];
          if(rule.noRepeat){
            if(a.val===b.val || b.val===c.val || a.val===c.val) continue;
          }

          for(const op1Key of opList){
            const op1Ent = ops.find(o => o.val === op1Key);
            if(!op1Ent) continue;
            const r1 = opExec(op1Key, a.val, b.val);
            if(r1 === null) continue;

            for(const op2Key of opList){
              const op2Ent = ops.find(o => o.val === op2Key && o !== op1Ent);
              if(!op2Ent) continue;
              const r2 = opExec(op2Key, r1, c.val);
              if(r2 === null) continue;

              if(r2 === this.targetNum){
                if(rule.requireNums && rule.requireNums > 3) continue;
                if(rule.requireOp){
                  if(!(op1Key === rule.requireOp || op2Key === rule.requireOp)) continue;
                }
                return [a, op1Ent, b, op2Ent, c];
              }
            }
          }
        }
      }
    }
    return null;
  }

  /* =========================================================
   * 入力
   * ========================================================= */
  handleClick(e){
    if(this.state !== 'rush' && this.state !== 'mission') return;
    if(this.autoBusy) return; // AUTO中は手動ロックを抑止（演出が崩れないように）

    const rect = this.canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    for(let i=0; i<this.entities.length; i++){
      const ent = this.entities[i];
      const dist = Math.hypot(ent.x - clickX, ent.y - clickY);
      if(dist < ent.r + 15){
        if(this.state === 'rush'){
          if(this.rushIsValidHit(ent)){
            this.setLockAim(ent.x, ent.y);
            this.rushOnHit(ent);
          } else this.rushOnMiss(ent);
        } else {
          this.trySelectMission(ent);
        }
        return;
      }
    }
  }

  /* =========================================================
   * 更新＆ゲームオーバー
   * ========================================================= */
  update(dt){
    this.scanAngle += dt * 1.5;
    this.bgScroll += dt * 20;

    this.entities.forEach(ent => { if(ent.scale < 1) ent.scale += dt * 5; if(ent.scale > 1) ent.scale = 1; });

    if(this.lockAim){
      this.lockAim.life -= 1;
      this.lockAim.alpha = Math.max(0, this.lockAim.life / 22);
      if(this.lockAim.life <= 0) this.lockAim = null;
    }

    if(this.state === 'rush' || this.state === 'mission'){
      this.timeLeft -= dt;
      if(this.timeLeft <= 0){
        this.timeLeft = 0;
        this.gameOver();
      }
      this.updateUI();
    }

    for(let i=this.effects.length-1; i>=0; i--){
      const eff = this.effects[i];
      eff.y -= 0.45;
      eff.life = (eff.life || 50) - 1;
      if(eff.life <= 0) this.effects.splice(i, 1);
    }
  }

  gameOver(){
    this.state = 'gameover';
    this.mode = 'gameover';

    document.getElementById('gameover-screen').classList.remove('hidden');
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('result-final').innerText = this.score;

    document.getElementById('result-title').innerText = 'RESULT';

    const container = document.getElementById('rank-list-container');
    container.innerHTML = '';
    let found = false;
    RANKS.forEach(rank => {
      const div = document.createElement('div');
      div.className = 'rank-item';
      let isMine = false;
      if(!found && this.score >= rank.min){
        isMine = true;
        found = true;
        div.classList.add('active');
      }
      div.innerHTML = `
        <div class="rank-name-col">
          <span class="rank-name-en">${rank.nameEn}</span>
          <span class="rank-name-ja">${rank.nameJa}</span>
        </div>
        <div class="rank-score">${rank.min}</div>
        <div class="rank-arrow">${isMine ? '◀ YOU' : ''}</div>
      `;
      container.appendChild(div);
    });

    this.updateCommander('panic');
    this.drawStaticMascot('mascot-canvas-over', 'panic');
    this.setAutoLockVisible(false);
    this.setAutoLockLabel('menu');

    this.setModeLabel('MODE: RESULT');
    this.setTarget('SCORE', String(this.score));
    this.setSub(`BEST COMBO: ${this.bestCombo}`);
    this.setGuide('MISSION COMPLETE', '結果画面です', '#00FFFF');
    this.setFormulaText('—', '#666');
  }

  /* =========================================================
   * 描画
   * ========================================================= */
  addEffect({text, x, y, color, size, life}){
    if(x === undefined) x = this.centerX + (Math.random() * 80 - 40);
    if(y === undefined) y = this.centerY + (Math.random() * 80 - 40);
    this.effects.push({ text, x, y, color: color || '#FFF', size: size || 20, life: life || 50 });
  }

  drawSciFiRadarBackground(ctx, x, y, r){
    const baseColor = (this.state === 'rush') ? '0, 255, 255' : '255, 220, 0';
    ctx.save();
    ctx.strokeStyle = `rgba(${baseColor}, 0.1)`;
    ctx.lineWidth = 1;
    const gridSize = 40;
    const offset = this.bgScroll % gridSize;
    for(let i=-r; i<r; i+=gridSize){
      ctx.beginPath(); ctx.moveTo(i - offset, -r); ctx.lineTo(i - offset, r); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-r, i + offset); ctx.lineTo(r, i + offset); ctx.stroke();
    }
    ctx.restore();

    ctx.strokeStyle = `rgba(${baseColor}, 0.3)`; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(x, y, r * 0.3, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(x, y, r * 0.6, 0, Math.PI*2); ctx.stroke();

    ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = `rgb(${baseColor})`;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke();
    ctx.shadowBlur = 0;

    ctx.strokeStyle = `rgba(${baseColor}, 0.2)`; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x-r, y); ctx.lineTo(x+r, y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-r); ctx.lineTo(x, y+r); ctx.stroke();

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.scanAngle);

    const grad = ctx.createLinearGradient(0, 0, r, 0);
    grad.addColorStop(0, `rgba(${baseColor}, 0)`);
    grad.addColorStop(1, `rgba(${baseColor}, 0.15)`);
    ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, r, -0.3, 0.3);
    ctx.fill();

    ctx.strokeStyle = `rgba(${baseColor}, 0.8)`; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(r*Math.cos(0.3), r*Math.sin(0.3)); ctx.lineTo(0,0); ctx.stroke();
    ctx.restore();
  }

  drawLockSight(x, y, r, alpha=1){
    this.ctx.strokeStyle = `rgba(255,0,255,${alpha})`;
    this.ctx.lineWidth = 2;
    this.ctx.shadowBlur = 10;
    this.ctx.shadowColor = 'rgba(255,0,255,0.9)';

    const gap = Math.PI / 4;
    this.ctx.beginPath(); this.ctx.arc(x, y, r, Math.PI + gap, 1.5 * Math.PI - gap); this.ctx.stroke();
    this.ctx.beginPath(); this.ctx.arc(x, y, r, 1.5 * Math.PI + gap, 2 * Math.PI - gap); this.ctx.stroke();
    this.ctx.beginPath(); this.ctx.arc(x, y, r, 0 + gap, 0.5 * Math.PI - gap); this.ctx.stroke();
    this.ctx.beginPath(); this.ctx.arc(x, y, r, 0.5 * Math.PI + gap, Math.PI - gap); this.ctx.stroke();

    this.ctx.shadowBlur = 0;
  }

  drawLockLine(){
    if(!this.lockAim) return;

    const a = this.lockAim.alpha;
    const fromX = this.lockFrom.x;
    const fromY = this.lockFrom.y;
    const toX = this.lockAim.x;
    const toY = this.lockAim.y;

    this.ctx.save();
    this.ctx.strokeStyle = `rgba(0,255,255,${0.25 * a})`;
    this.ctx.lineWidth = 2;
    this.ctx.setLineDash([6, 6]);
    this.ctx.beginPath();
    this.ctx.moveTo(fromX, fromY);
    this.ctx.lineTo(toX, toY);
    this.ctx.stroke();
    this.ctx.setLineDash([]);

    this.drawLockSight(toX, toY, 26, a);
    this.ctx.restore();
  }

  draw(){
    this.ctx.fillStyle = '#050510';
    this.ctx.fillRect(0, 0, this.width, this.height);

    this.drawSciFiRadarBackground(this.ctx, this.centerX, this.centerY, this.radarRadius);

    // ★司令→ターゲット ロックオン演出
    this.drawLockLine();

    // MISSIONの式ロック線（従来）
    if(this.mode === 'mission' && this.formulaStack.length > 0){
      const now = Date.now();
      for(let i=0; i<this.formulaStack.length - 1; i++){
        const curr = this.formulaStack[i];
        const next = this.formulaStack[i+1];
        const age = now - next.time;

        if(age < 1000){
          const alpha = 1 - (age / 1000);
          this.ctx.strokeStyle = `rgba(255, 0, 255, ${alpha})`;
          this.ctx.lineWidth = 3;
          this.ctx.shadowBlur = 15;
          this.ctx.shadowColor = '#FF00FF';
          this.ctx.beginPath();
          this.ctx.moveTo(curr.entity.x, curr.entity.y);
          this.ctx.lineTo(next.entity.x, next.entity.y);
          this.ctx.stroke();
          this.ctx.shadowBlur = 0;
        } else {
          this.ctx.strokeStyle = `rgba(255, 0, 255, 0.2)`;
          this.ctx.lineWidth = 1;
          this.ctx.beginPath();
          this.ctx.moveTo(curr.entity.x, curr.entity.y);
          this.ctx.lineTo(next.entity.x, next.entity.y);
          this.ctx.stroke();
        }
      }
    }

    // エンティティ
    this.entities.forEach(ent => {
      const size = ent.r * ent.scale;

      if(this.mode === 'rush'){
        const isValid = (this.state === 'rush') ? this.rushIsValidHit(ent) : false;
        this.ctx.fillStyle = isValid ? '#FFDC00' : '#EEE';
      } else {
        if(ent.type === 'num') this.ctx.fillStyle = ent.selected ? '#FFDC00' : '#EEE';
        else this.ctx.fillStyle = ent.selected ? '#00FFFF' : '#0074D9';
      }

      this.ctx.beginPath(); this.ctx.arc(ent.x, ent.y, size, 0, Math.PI*2); this.ctx.fill();

      this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
      this.ctx.beginPath();
      this.ctx.ellipse(ent.x - size*0.3, ent.y - size*0.3, size*0.2, size*0.1, Math.PI/4, 0, Math.PI*2);
      this.ctx.fill();

      if(this.mode === 'mission' && ent.selected){
        this.drawLockSight(ent.x, ent.y, size + 5, 1);
        if(ent.order){
          this.ctx.fillStyle = '#FF4136';
          this.ctx.beginPath(); this.ctx.arc(ent.x + 12, ent.y - 12, 8, 0, Math.PI*2); this.ctx.fill();
          this.ctx.fillStyle = '#fff';
          this.ctx.font = 'bold 10px Arial';
          this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
          this.ctx.fillText(ent.order, ent.x + 12, ent.y - 12);
        }
      }

      this.ctx.fillStyle = '#000';
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';
      this.ctx.font = size > 20 ? 'bold 22px Arial' : 'bold 16px Arial';
      const label = (ent.type === 'num') ? ent.val : (OPS[ent.val]?.label ?? '?');
      this.ctx.fillText(label, ent.x, ent.y);
    });

    this.effects.forEach(eff => {
      this.ctx.fillStyle = eff.color;
      this.ctx.font = `bold ${eff.size || 20}px Arial`;
      this.ctx.textAlign = 'center';
      this.ctx.fillText(eff.text, eff.x, eff.y);
    });
  }

  loop(timestamp){
    const dt = (timestamp - this.lastTime) / 1000;
    this.lastTime = timestamp;
    const safeDt = isFinite(dt) ? clamp(dt, 0, 0.05) : 0.016;

    this.update(safeDt);
    this.draw();
    requestAnimationFrame(this.loop);
  }

  /* =========================================================
   * マスコット＆司令官
   * ========================================================= */
  drawStaticMascot(canvasId, mood){
    const c = document.getElementById(canvasId);
    if(!c) return;
    const cx = c.getContext('2d');
    cx.clearRect(0,0,100,100);
    this.drawEbiGratinFace(cx, 50, 50, 40, mood);
  }

  updateCommander(mood){
    this.commCtx.clearRect(0,0,70,70);
    this.drawEbiGratinFace(this.commCtx, 35, 35, 25, mood);
  }

  drawEbiGratinFace(ctx, x, y, size, mood){
    ctx.lineWidth = 2;
    ctx.fillStyle = '#FFDB58';
    if(mood === 'panic') ctx.fillStyle = '#A0A0FF';
    ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#8B4513';
    ctx.beginPath(); ctx.ellipse(x - size*0.4, y - size*0.5, size*0.2, size*0.1, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(x + size*0.3, y - size*0.4, size*0.25, size*0.15, 0, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = '#000';
    ctx.fillStyle = '#000';
    if(mood === 'happy'){
      ctx.beginPath(); ctx.arc(x - size*0.3, y, size*0.15, Math.PI, 0); ctx.stroke();
      ctx.beginPath(); ctx.arc(x + size*0.3, y, size*0.15, Math.PI, 0); ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(x - size*0.3, y + size*0.1, size*0.1, 0, Math.PI*2);
      ctx.arc(x + size*0.3, y + size*0.1, size*0.1, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.beginPath();
    if(mood === 'happy'){
      ctx.arc(x, y + size*0.1, size*0.3, 0, Math.PI); ctx.fill();
    } else if(mood === 'panic'){
      ctx.moveTo(x - size*0.2, y + size*0.32);
      ctx.lineTo(x + size*0.2, y + size*0.32);
      ctx.stroke();
    } else {
      ctx.arc(x, y + size*0.1, size*0.3, 0.2*Math.PI, 0.8*Math.PI);
      ctx.stroke();
    }
  }
}

window.onload = () => { window.game = new Game(); };
</script>
</body>
</html>
