<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bubble Shot - Burst Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510; /* より深い宇宙の色 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: #00d4ff;
            text-shadow: 0 0 10px #00d4ff;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Courier New', Courier, monospace; /* メカニックなフォント */
        }
        .hud-bottom {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            pointer-events: auto;
        }
        /* 必殺技ボタン */
        #auto-lock-btn {
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #00d4ff;
            color: #00d4ff;
            padding: 15px 40px;
            border-radius: 5px; /* 角ばらせてメカっぽく */
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }
        #auto-lock-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.5), transparent);
            transition: 0.5s;
        }
        #auto-lock-btn:hover::before {
            left: 100%;
        }
        #auto-lock-btn:disabled {
            border-color: #555;
            color: #555;
            box-shadow: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score">SCORE: 00000</div>
            <div id="target">TARGET: --</div>
        </div>
        <div class="hud-bottom">
            <button id="auto-lock-btn">AUTO LOCK [READY]</button>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * Bubble Shot Ver 3.1 - Hi-MAT Full Burst Edition
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const targetEl = document.getElementById('target');
const autoBtn = document.getElementById('auto-lock-btn');

// --- 設定 ---
const COLS = 6;
const ROWS = 7;
const BUBBLE_RADIUS_RATIO = 0.8;
let BUBBLE_SIZE = 0;
let OFFSET_X = 0;
let OFFSET_Y = 0;

// --- 状態 ---
let score = 0;
let targetNumber = 10;
let autoLockCharges = 3;
let bubbles = [];
let selectedBubbles = [];
let particles = [];
let floatingTexts = [];
let lasers = []; // レーザー描画用配列
let isDragging = false;
let dpr = 1;

// 演出用ステート
let autoLockState = 'idle'; // idle, scanning, locking, firing
let scanRadius = 0;
let shakeIntensity = 0; // 画面振動の強さ
let lockOnTargets = []; // オートロック対象

const TYPES = ['number', 'operator'];
const OPERATORS = ['+', '-', '×']; 

// --- 初期化 ---
function init() {
    resize();
    window.addEventListener('resize', resize);
    
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', (e) => handleStart(e.touches[0]), {passive: false});
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0]); }, {passive: false});
    canvas.addEventListener('touchend', handleEnd);
    
    autoBtn.addEventListener('click', triggerAutoLock);

    resetGame();
    loop();
}

function resize() {
    dpr = window.devicePixelRatio || 1;
    const width = window.innerWidth;
    const height = window.innerHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    // setTransformはdrawループ内で毎回リセットしつつshakeを適用するため、ここでは計算用変数のみ更新
    
    BUBBLE_SIZE = Math.min(width / (COLS + 1), height / (ROWS + 3));
    OFFSET_X = (width - (BUBBLE_SIZE * COLS)) / 2 + BUBBLE_SIZE / 2;
    OFFSET_Y = (height - (BUBBLE_SIZE * ROWS * 0.9)) / 2 + BUBBLE_SIZE;

    if(bubbles.length > 0) updateBubblePositions();
}

// --- ゲーム進行 ---
function resetGame() {
    score = 0;
    autoLockCharges = 3;
    scoreEl.innerText = `SCORE: ${score.toString().padStart(5, '0')}`;
    updateAutoBtn();
    
    targetNumber = Math.floor(Math.random() * 10) + 5;
    targetEl.innerText = `TARGET: ${targetNumber}`;

    initBoard();
}

function updateAutoBtn() {
    if (autoLockCharges > 0) {
        autoBtn.innerText = `AUTO LOCK [${autoLockCharges}]`;
        autoBtn.disabled = false;
    } else {
        autoBtn.innerText = `RECHARGING...`;
        autoBtn.disabled = true;
    }
}

function initBoard(retry = 0) {
    bubbles = [];
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            let cx = c * BUBBLE_SIZE + OFFSET_X;
            if (r % 2 !== 0) cx += BUBBLE_SIZE / 2;
            if (r % 2 !== 0 && c === COLS - 1) continue;
            let cy = r * (BUBBLE_SIZE * 0.9) + OFFSET_Y;
            bubbles.push(createRandomBubble(cx, cy, c, r));
        }
    }
    if (!checkSolvability() && retry < 2) initBoard(retry + 1);
}

function createRandomBubble(x, y, col, row) {
    const isOp = Math.random() < 0.3;
    return {
        id: Math.random().toString(36).substr(2, 9),
        col: col, row: row, x: x, y: y,
        type: isOp ? 'operator' : 'number',
        value: isOp ? OPERATORS[Math.floor(Math.random() * OPERATORS.length)] : Math.floor(Math.random() * 9) + 1,
        color: isOp ? '#ff0055' : '#00aaff',
        scale: 1,
        removing: false,
        lockScale: 0 // ロックオンサイトのアニメーション用
    };
}

function updateBubblePositions() {
    bubbles.forEach(b => {
        let cx = b.col * BUBBLE_SIZE + OFFSET_X;
        if (b.row % 2 !== 0) cx += BUBBLE_SIZE / 2;
        let cy = b.row * (BUBBLE_SIZE * 0.9) + OFFSET_Y;
        b.x = cx;
        b.y = cy;
    });
}

// --- 入力 ---
function handleStart(pos) {
    if (autoLockState !== 'idle') return;
    isDragging = true;
    selectedBubbles = [];
    checkHit(pos.clientX, pos.clientY);
}
function handleMove(pos) {
    if (!isDragging) return;
    checkHit(pos.clientX, pos.clientY);
}
function handleEnd() {
    if (!isDragging) return;
    isDragging = false;
    submitSelection();
}

function checkHit(tx, ty) {
    for (let b of bubbles) {
        if (b.removing) continue;
        const dx = tx - b.x;
        const dy = ty - b.y;
        if (dx * dx + dy * dy < (BUBBLE_SIZE / 2) ** 2) {
            if (selectedBubbles.length === 0) {
                if (b.type === 'number') selectedBubbles.push(b);
            } else {
                const last = selectedBubbles[selectedBubbles.length - 1];
                if (selectedBubbles.length > 1 && selectedBubbles[selectedBubbles.length - 2] === b) {
                    selectedBubbles.pop();
                    return;
                }
                if (!selectedBubbles.includes(b) && isAdjacent(last, b) && isValidNext(last, b)) {
                    selectedBubbles.push(b);
                    b.scale = 1.2; 
                }
            }
        }
    }
}

function isAdjacent(b1, b2) {
    const dist = Math.sqrt((b1.x - b2.x)**2 + (b1.y - b2.y)**2);
    return dist < BUBBLE_SIZE * 1.2;
}

function isValidNext(prev, current) {
    if (prev.type === 'number' && current.type === 'operator') return true;
    if (prev.type === 'operator' && current.type === 'number') return true;
    return false;
}

// --- 判定・計算 ---
function submitSelection() {
    if (selectedBubbles.length < 3) { selectedBubbles = []; return; }
    if (selectedBubbles[selectedBubbles.length - 1].type === 'operator') { selectedBubbles = []; return; }

    let expression = "";
    selectedBubbles.forEach(b => {
        let val = b.value;
        if (val === '×') val = '*';
        expression += val;
    });

    try {
        const result = new Function('return ' + expression)();
        if (result === targetNumber) {
            handleSuccess(result);
        } else {
            createFloatingText(selectedBubbles[selectedBubbles.length-1].x, selectedBubbles[selectedBubbles.length-1].y, "MISS", '#ff5555');
            selectedBubbles = [];
        }
    } catch (e) { selectedBubbles = []; }
}

function handleSuccess(result) {
    const lengthBonus = selectedBubbles.length * 100;
    score += lengthBonus;
    scoreEl.innerText = `SCORE: ${score.toString().padStart(5, '0')}`;

    const lastBubble = selectedBubbles[selectedBubbles.length - 1];
    let title = "HIT";
    let color = "#fff";
    if (selectedBubbles.length >= 7) { title = "FULL BURST!"; color = "#ff00ff"; }
    else if (selectedBubbles.length >= 5) { title = "SENSATIONAL!"; color = "#00ffff"; }
    
    createFloatingText(lastBubble.x, lastBubble.y, title, color, 30);

    selectedBubbles.forEach(b => {
        b.removing = true;
        createParticles(b.x, b.y, b.color);
    });

    selectedBubbles = [];
    
    setTimeout(() => {
        fillBoard();
        targetNumber = Math.floor(Math.random() * 10) + 5;
        targetEl.innerText = `TARGET: ${targetNumber}`;
    }, 400);
}

function fillBoard() {
    bubbles = bubbles.map(b => {
        if (b.removing) return createRandomBubble(b.x, b.y, b.col, b.row);
        return b;
    });
}

// --- オートロック（ハイマットフルバースト） ---
function triggerAutoLock() {
    if (autoLockCharges <= 0 || autoLockState !== 'idle') return;
    
    const path = findBestPath(targetNumber);
    if (path) {
        autoLockCharges--;
        updateAutoBtn();
        startBurstSequence(path);
    } else {
        createFloatingText(canvas.width/2/dpr, canvas.height/2/dpr, "NO TARGET", "#888");
    }
}

function findBestPath(target) {
    let bestPath = null;
    let maxLength = 0;
    const numbers = bubbles.filter(b => b.type === 'number');
    
    for (let startNode of numbers) {
        dfs(startNode, [startNode]);
    }
    function dfs(current, path) {
        if (path.length > 9) return;
        if (current.type === 'number' && path.length >= 3) {
            let exp = "";
            path.forEach(b => { let v = b.value; if (v === '×') v = '*'; exp += v; });
            try {
                if (new Function('return ' + exp)() === target) {
                    if (path.length > maxLength) { maxLength = path.length; bestPath = [...path]; }
                }
            } catch(e){}
        }
        bubbles.forEach(next => {
            if (!path.includes(next) && isAdjacent(current, next) && isValidNext(current, next)) {
                dfs(next, [...path, next]);
            }
        });
    }
    return bestPath;
}
function checkSolvability() { return findBestPath(targetNumber) !== null; }

// ★演出シーケンス
function startBurstSequence(path) {
    autoLockState = 'scanning';
    scanRadius = 0;
    lockOnTargets = path; // パスを保存
    
    // Phase 1: Scan (0.6s)
    setTimeout(() => {
        autoLockState = 'locking';
        
        // Phase 2: Multi-Lock (Seqential)
        let i = 0;
        const interval = setInterval(() => {
            if (i < path.length) {
                // ロックオンアニメーション開始
                path[i].lockScale = 2.0; // 最初大きく
                // ここで音を鳴らしたい (ピピッ)
                i++;
            } else {
                clearInterval(interval);
                
                // Phase 3: Full Burst (Wait a bit then fire)
                setTimeout(() => {
                    autoLockState = 'firing';
                    shakeIntensity = 15; // 画面を揺らす
                    
                    // レーザー生成
                    path.forEach(b => {
                        lasers.push({
                            tx: b.x, ty: b.y,
                            life: 1.0,
                            color: `hsl(${Math.random()*360}, 100%, 70%)`
                        });
                        b.removing = true; // 内部的には消去フラグ
                        createParticles(b.x, b.y, b.color); // 爆発
                    });
                    
                    // 終了処理
                    setTimeout(() => {
                        autoLockState = 'idle';
                        handleSuccessAuto(path.length); // スコア処理のみ
                        fillBoard();
                        targetNumber = Math.floor(Math.random() * 10) + 5;
                        targetEl.innerText = `TARGET: ${targetNumber}`;
                    }, 800);
                    
                }, 400); // 全ロック完了から発射までの溜め
            }
        }, 80); // ロックオン速度
        
    }, 600); // スキャン時間
}

// オート用成功処理（重複を避けるため簡易化）
function handleSuccessAuto(len) {
    const lengthBonus = len * 150;
    score += lengthBonus;
    scoreEl.innerText = `SCORE: ${score.toString().padStart(5, '0')}`;
    createFloatingText(canvas.width/2/dpr, canvas.height/2/dpr, "TARGET DESTROYED", "#00ffff", 40);
}


// --- 描画ループ ---
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

function update() {
    // 画面揺れの減衰
    if (shakeIntensity > 0) shakeIntensity *= 0.9;
    if (shakeIntensity < 0.5) shakeIntensity = 0;

    bubbles.forEach(b => {
        if (b.scale > 1) b.scale -= 0.05;
        // ロックオンサイトのアニメーション（縮小しながらフィット）
        if (b.lockScale > 1) b.lockScale -= 0.1;
        if (b.lockScale < 1 && b.lockScale > 0) b.lockScale = 1;
    });

    particles.forEach((p, index) => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.05;
        if (p.life <= 0) particles.splice(index, 1);
    });
    
    floatingTexts.forEach((t, index) => {
        t.y -= 1; t.life -= 0.02;
        if (t.life <= 0) floatingTexts.splice(index, 1);
    });

    lasers.forEach((l, index) => {
        l.life -= 0.1;
        if (l.life <= 0) lasers.splice(index, 1);
    });

    if (autoLockState === 'scanning') {
        scanRadius += 25;
    }
}

function draw() {
    // 画面揺れ適用
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // リセット
    if (shakeIntensity > 0) {
        const dx = (Math.random() - 0.5) * shakeIntensity;
        const dy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(dx, dy);
    }
    
    ctx.clearRect(-50, -50, canvas.width/dpr + 100, canvas.height/dpr + 100);

    // バブル描画
    bubbles.forEach(b => {
        // 発射フェーズでremovingになっても、レーザー消えるまでは少し残すか、即消して爆発させるか
        // ここでは即消えるがパーティクルが出る
        if (b.removing && autoLockState !== 'firing') return; 
        if (b.removing && autoLockState === 'firing' && lasers.length === 0) return;

        const isSelected = selectedBubbles.includes(b);
        // オートロック中のターゲット判定
        const isLocked = (autoLockState === 'locking' || autoLockState === 'firing') && lockOnTargets.includes(b);
        
        const size = (BUBBLE_SIZE / 2 * BUBBLE_RADIUS_RATIO) * b.scale;
        
        ctx.beginPath();
        ctx.arc(b.x, b.y, size, 0, Math.PI * 2);
        ctx.fillStyle = b.color;
        // 選択中は少し明るく
        if (isSelected) ctx.fillStyle = adjustColor(b.color, 40);
        
        ctx.fill();
        
        // 枠線
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.stroke();

        // 文字
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(b.value, b.x, b.y + size * 0.1);

        // ★修正点：円形ターゲットスコープ（手動選択時 & オートロック時）
        if (isSelected || (isLocked && b.lockScale > 0)) {
            const scale = isLocked ? b.lockScale : 1;
            drawReticle(b.x, b.y, size * 1.3 * scale, isLocked ? '#ff0055' : '#00ffaa');
        }
    });
    
    // スキャン演出
    if (autoLockState === 'scanning') {
        ctx.strokeStyle = 'rgba(0, 255, 100, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(canvas.width/2/dpr, canvas.height/2/dpr, scanRadius, 0, Math.PI * 2);
        ctx.stroke();
    }

    // レーザー演出 (Full Burst)
    if (autoLockState === 'firing') {
        ctx.globalCompositeOperation = 'lighter'; // 加算合成で光らせる
        lasers.forEach(l => {
            // 画面下中央から発射
            const startX = canvas.width / 2 / dpr;
            const startY = canvas.height / dpr;
            
            // ビーム本体
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(l.tx, l.ty);
            ctx.lineWidth = 15 * l.life; // 徐々に細くなる
            ctx.strokeStyle = l.color;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // 芯（白）
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(l.tx, l.ty);
            ctx.lineWidth = 5 * l.life;
            ctx.strokeStyle = '#fff';
            ctx.stroke();
        });
        ctx.globalCompositeOperation = 'source-over'; // 戻す
        
        // フラッシュ
        ctx.fillStyle = `rgba(255, 255, 255, ${shakeIntensity * 0.02})`;
        ctx.fillRect(0, 0, canvas.width/dpr, canvas.height/dpr);
    }

    // パーティクル & テキスト
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    });

    floatingTexts.forEach(t => {
        ctx.globalAlpha = Math.min(1, t.life);
        ctx.fillStyle = t.color;
        ctx.font = `bold ${t.size}px Arial Black`;
        ctx.textAlign = 'center';
        ctx.fillText(t.text, t.x, t.y);
        ctx.globalAlpha = 1.0;
    });
}

// ★スコープ描画関数
function drawReticle(x, y, radius, color) {
    ctx.save();
    ctx.translate(x, y);
    // 回転させる
    ctx.rotate(Date.now() / 200);
    
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.shadowBlur = 5;
    ctx.shadowColor = color;
    
    // 外円
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // 内側のカギカッコ的なやつ
    const innerR = radius * 0.7;
    ctx.beginPath();
    ctx.arc(0, 0, innerR, 0, Math.PI * 1.5); // 欠けた円
    ctx.stroke();
    
    // 十字線
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-radius * 1.2, 0); ctx.lineTo(radius * 1.2, 0);
    ctx.moveTo(0, -radius * 1.2); ctx.lineTo(0, radius * 1.2);
    ctx.stroke();
    
    ctx.restore();
}

function adjustColor(hex, amount) {
    return hex; // 簡易版につきそのまま返す（本来は色調整）
}

function createParticles(x, y, color) {
    for (let i = 0; i < 15; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 15,
            vy: (Math.random() - 0.5) * 15,
            life: 1.0, color: color, size: Math.random() * 6 + 2
        });
    }
}

function createFloatingText(x, y, text, color, size = 20) {
    floatingTexts.push({ x: x, y: y, text: text, color: color, life: 2.0, size: size });
}

init();

</script>
</body>
</html>
