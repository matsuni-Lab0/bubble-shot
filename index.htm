<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bubble Shot: Hi-MAT Final</title>
    <style>
        /* --- CSS: 重厚なコックピット風UI --- */
        body {
            margin: 0; overflow: hidden; background-color: #020205; color: white;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none; user-select: none; -webkit-user-select: none;
        }
        #game-container {
            position: relative; width: 100vw; height: 100dvh; overflow: hidden;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* UIレイヤー */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }

        /* ヘッダーエリア */
        #top-hud {
            display: flex; justify-content: space-between; align-items: flex-start;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0, 50, 100, 0.8), transparent);
        }

        /* 司令官通信ウィンドウ */
        #comm-window {
            width: 70px; height: 70px;
            border: 2px solid #00FFFF; border-radius: 50%;
            background: rgba(0, 20, 30, 0.7);
            box-shadow: 0 0 15px #00FFFF;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; position: relative;
        }
        #comm-scanline {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,255,255,0.1) 51%);
            background-size: 100% 4px; pointer-events: none;
        }

        /* スコア・タイム */
        #status-panel { text-align: right; }
        .hud-label { font-size: 10px; color: #00FFFF; letter-spacing: 2px; text-shadow: 0 0 5px #00FFFF; }
        .hud-value { font-size: 24px; font-weight: bold; font-family: 'Courier New', monospace; color: #fff; }

        /* ミッション表示（画面中央上） */
        #mission-hud {
            position: absolute; top: 90px; width: 100%; text-align: center; pointer-events: none;
        }
        #mission-title {
            font-size: 36px; font-weight: 900; color: #FFD700;
            text-shadow: 0 0 20px #FFD700; letter-spacing: 3px;
            font-family: 'Arial Black', sans-serif;
            transition: transform 0.1s;
        }
        #mission-desc {
            font-size: 14px; color: #fff; background: rgba(0,0,0,0.6);
            padding: 4px 12px; border-radius: 4px; display: inline-block;
            border: 1px solid #555; margin-top: 5px;
        }
        .pulse-text { animation: pulse 0.8s infinite alternate; }
        @keyframes pulse { from { opacity: 1; transform: scale(1); } to { opacity: 0.8; transform: scale(0.95); } }

        /* フッターエリア */
        #bottom-hud {
            padding: 20px; display: flex; justify-content: flex-end; align-items: flex-end;
            background: linear-gradient(to top, rgba(0, 20, 30, 0.9), transparent);
            pointer-events: auto;
            min-height: 80px;
        }

        #formula-bar {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            text-align: center; font-size: 24px; font-weight: bold; color: #fff;
            text-shadow: 0 0 10px #00FFFF; font-family: monospace;
            pointer-events: none;
        }

        #auto-lock-sub {
            width: 70px; height: 70px; border-radius: 50%;
            border: 2px solid #00FF00; color: #00FF00;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-size: 10px; font-weight: bold; background: rgba(0, 255, 0, 0.1);
            cursor: pointer; pointer-events: auto; box-shadow: 0 0 10px #00FF00;
            margin-left: auto; /* 右寄せ */
        }
        #auto-lock-sub:active { transform: scale(0.9); background: #00FF00; color: #000; }

        /* タイムバー */
        #time-gauge {
            position: absolute; top: 0; left: 0; width: 100%; height: 4px; background: #333;
        }
        #time-fill {
            width: 100%; height: 100%; background: #00FFFF;
            box-shadow: 0 0 10px #00FFFF; transition: width 0.1s linear;
        }

        /* スタート画面 */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 50;
        }
        .title-text {
            font-size: 40px; color: #00FFFF; font-weight: 900;
            text-shadow: 0 0 20px #00FFFF; margin-bottom: 10px; text-align: center;
            font-family: 'Arial Black', sans-serif;
        }
        .start-btn {
            padding: 15px 50px; border: 2px solid #FFD700; color: #FFD700;
            background: transparent; font-size: 20px; font-weight: bold;
            cursor: pointer; box-shadow: 0 0 15px #FFD700; margin-top: 30px;
        }
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="time-gauge"><div id="time-fill"></div></div>

        <div id="top-hud">
            <div id="comm-window">
                <canvas id="comm-canvas" width="70" height="70"></canvas>
                <div id="comm-scanline"></div>
            </div>
            <div id="status-panel">
                <div class="hud-label">SCORE</div>
                <div class="hud-value" id="score-val">00000</div>
                <div class="hud-label">TIME</div>
                <div class="hud-value" id="time-val">60</div>
            </div>
        </div>

        <div id="mission-hud">
            <div id="mission-title" class="pulse-text">ODD NUMS</div>
            <div id="mission-desc">奇数(1,3,5...)をロックして撃て</div>
        </div>

        <div id="formula-bar">Trace to Lock</div>

        <div id="bottom-hud">
            <div id="auto-lock-sub" onclick="game.autoLock()">
                MAP<br>WPN
            </div>
        </div>
    </div>

    <div id="start-overlay">
        <div class="title-text">Hi-MAT<br>BURST</div>
        <div style="color:#ccc; font-size:14px;">Trace targets > Release to Fire</div>
        <button class="start-btn" onclick="game.start()">LAUNCH</button>
    </div>
</div>

<script>
/**
 * Bubble Shot Ver 4.2: Hi-MAT Final Fix
 * - 文字色を白に修正
 * - 操作を「なぞり（ドラッグ）」に戻し、マルチロック感を再現
 */

const OPS = {
    add: { label: '+', op: '+' }, 
    sub: { label: '-', op: '-' },
    mul: { label: '×', op: '*' }, 
    div: { label: '÷', op: '/' }
};

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.commCanvas = document.getElementById('comm-canvas');
        this.commCtx = this.commCanvas.getContext('2d');

        this.resize();
        window.addEventListener('resize', () => this.resize());

        // 入力：なぞり操作（ドラッグ）
        this.canvas.addEventListener('pointerdown', (e) => this.handleStart(e));
        this.canvas.addEventListener('pointermove', (e) => this.handleMove(e));
        this.canvas.addEventListener('pointerup', () => this.handleEnd());
        this.canvas.addEventListener('pointercancel', () => this.handleEnd());

        // 状態
        this.state = 'menu'; 
        this.score = 0;
        this.maxTime = 60;
        this.timeLeft = 60;
        this.isDragging = false;
        
        this.bubbles = [];
        this.selectedBubbles = [];
        this.lasers = [];
        this.particles = [];
        this.texts = [];
        
        this.mission = null;
        this.combo = 0;
        this.maxNum = 9; // 初期値

        this.lastTime = 0;
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);

        this.drawCommander('normal');
    }

    resize() {
        this.dpr = window.devicePixelRatio || 1;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width * this.dpr;
        this.canvas.height = this.height * this.dpr;
        this.ctx.scale(this.dpr, this.dpr);
        this.bubbleR = Math.min(this.width, this.height) / 8;
    }

    start() {
        document.getElementById('start-overlay').classList.add('hidden');
        this.state = 'playing';
        this.score = 0;
        this.timeLeft = this.maxTime;
        this.bubbles = [];
        this.replenishBubbles(15);
        this.setNextMission();
        this.updateUI();
    }

    // --- ミッション ---
    setNextMission() {
        const rules = [
            { id: 'odd', title: 'ODD', desc: '奇数 (1,3,5...) をなぞって撃て', color: '#FF0055' },
            { id: 'even', title: 'EVEN', desc: '偶数 (2,4,6...) をなぞって撃て', color: '#00CCFF' },
            { id: 'asc', title: 'ASCEND', desc: '小さい順 (1→2→3) になぞれ', color: '#00FF00' },
            { id: 'desc', title: 'DESCEND', desc: '大きい順 (9→8→7) になぞれ', color: '#FFCC00' }
        ];

        if (Math.random() < 0.25 && this.score > 500) {
            this.setBossMission();
            return;
        }

        let next;
        do { next = rules[Math.floor(Math.random()*rules.length)]; } 
        while(this.mission && this.mission.id === next.id);
        
        this.mission = next;
        this.updateMissionUI();
        this.drawCommander('normal');
    }

    setBossMission() {
        const targets = [
            { t: 6, op: 'mul', title: 'TARGET: 6', desc: '掛け算で作れ (2×3)' },
            { t: 12, op: 'mul', title: 'TARGET: 12', desc: '掛け算で作れ (3×4)' },
            { t: 10, op: 'add', title: 'TARGET: 10', desc: '足し算で作れ (5+5)' }
        ];
        const t = targets[Math.floor(Math.random()*targets.length)];
        this.mission = { id: 'calc', title: t.title, desc: t.desc, targetVal: t.t, targetOp: t.op, color: '#FFFFFF' };
        
        this.updateMissionUI();
        this.drawCommander('panic');
        this.ensureBossSolvable();
    }

    updateMissionUI() {
        const t = document.getElementById('mission-title');
        const d = document.getElementById('mission-desc');
        t.innerText = this.mission.title;
        t.style.color = this.mission.color;
        d.innerText = this.mission.desc;
        t.classList.remove('pulse-text');
        void t.offsetWidth;
        t.classList.add('pulse-text');
        document.getElementById('formula-bar').innerText = "";
    }

    // --- なぞり操作 ---
    handleStart(e) {
        if (this.state !== 'playing') return;
        this.isDragging = true;
        this.selectedBubbles = [];
        this.handleMove(e);
    }

    handleMove(e) {
        if (!this.isDragging) return;
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        for (let b of this.bubbles) {
            const dist = Math.hypot(b.x - x, b.y - y);
            if (dist < b.r * 1.0) {
                this.tryAddBubble(b);
            }
        }
    }

    handleEnd() {
        this.isDragging = false;
        if (this.selectedBubbles.length > 0) {
            this.fire();
        }
    }

    tryAddBubble(b) {
        if (this.selectedBubbles.includes(b)) return; // 既に選択済みなら無視

        // ルールチェック
        let isValid = false;

        if (this.mission.id === 'calc') {
            // 計算モード: Num -> Op -> Num の順
            const last = this.selectedBubbles[this.selectedBubbles.length - 1];
            if (!last) {
                if (b.type === 'num') isValid = true;
            } else {
                if (last.type === 'num' && b.type === 'op') isValid = true;
                if (last.type === 'op' && b.type === 'num') isValid = true;
            }
        } else {
            // 反射神経モード: ルールに合う数字のみ
            if (b.type !== 'num') return;
            const last = this.selectedBubbles[this.selectedBubbles.length - 1];
            
            if (this.mission.id === 'odd') isValid = (b.val % 2 !== 0);
            else if (this.mission.id === 'even') isValid = (b.val % 2 === 0);
            else if (this.mission.id === 'asc') {
                isValid = (!last || b.val > last.val);
            }
            else if (this.mission.id === 'desc') {
                isValid = (!last || b.val < last.val);
            }
        }

        if (isValid) {
            b.selected = true;
            this.selectedBubbles.push(b);
            b.scale = 1.3; // 選択時の反応
            this.updateFormulaBar();
        }
    }

    updateFormulaBar() {
        let txt = "";
        this.selectedBubbles.forEach(b => {
             txt += (b.type==='op' ? OPS[b.val].label : b.val) + " ";
        });
        document.getElementById('formula-bar').innerText = txt;
    }

    // --- 発射 ---
    fire() {
        let success = false;
        let bonus = 0;
        const selected = this.selectedBubbles;

        if (this.mission.id === 'calc') {
            if (selected.length >= 3) {
                let exp = "";
                let hasOp = false;
                selected.forEach(b => {
                    let v = b.val;
                    if (b.type === 'op') {
                        if (b.val === this.mission.targetOp) hasOp = true;
                        v = OPS[b.val].op;
                    }
                    exp += v;
                });
                try {
                    if (new Function('return '+exp)() === this.mission.targetVal && hasOp) {
                        success = true; bonus = 5000;
                    }
                } catch(e){}
            }
        } else {
            // 反射神経モードは1個以上でOK、多いほど高得点
            if (selected.length > 0) {
                success = true;
                bonus = selected.length * 200;
            }
        }

        if (success) {
            this.triggerBurst(selected, this.mission.color);
            this.score += bonus;
            this.addText(this.width/2, this.height/2, `BURST! +${bonus}`, this.mission.color, 40);
            this.drawCommander('happy');
            this.timeLeft = Math.min(this.maxTime, this.timeLeft + (this.mission.id==='calc'?10:1));

            if (this.mission.id === 'calc') {
                this.setNextMission();
            } else {
                this.combo++;
                if (this.combo > 2) { this.combo = 0; this.setNextMission(); }
            }
        } else {
            selected.forEach(b => b.selected = false);
            this.addText(this.width/2, this.height/2, "MISS", "#888");
            this.timeLeft -= 2;
            this.drawCommander('panic');
        }

        this.selectedBubbles = [];
        document.getElementById('formula-bar').innerText = "";
    }

    autoLock() {
        if (this.state !== 'playing') return;
        const targets = [];
        this.bubbles.forEach(b => {
            let match = false;
            if (this.mission.id === 'odd') match = (b.type === 'num' && b.val % 2 !== 0);
            else if (this.mission.id === 'even') match = (b.type === 'num' && b.val % 2 === 0);
            else match = true; // その他は全消し
            if (match) targets.push(b);
        });
        if (targets.length > 0) {
            this.triggerBurst(targets, '#00FF00');
            this.score += targets.length * 100;
            this.addText(this.width/2, this.height/2, "MAP WPN!!", "#00FF00", 50);
            this.replenishBubbles(15);
        }
    }

    triggerBurst(targets, color) {
        targets.forEach(b => {
            this.lasers.push({ tx: b.x, ty: b.y, life: 1.0, color: color });
            this.spawnParticles(b.x, b.y, color);
            const idx = this.bubbles.indexOf(b);
            if (idx > -1) this.bubbles.splice(idx, 1);
        });
        this.replenishBubbles(15 - this.bubbles.length);
    }

    // --- 生成系 ---
    replenishBubbles(count) {
        if (count <= 0) return;
        for(let i=0; i<count; i++) {
            let type = 'num';
            let val = Math.floor(Math.random()*9)+1;
            if (this.mission && this.mission.id === 'calc' && Math.random()<0.4) {
                type = 'op';
                val = ['add','mul'][Math.floor(Math.random()*2)];
            }
            this.bubbles.push({
                x: Math.random() * (this.width - 60) + 30,
                y: Math.random() * (this.height - 250) + 150,
                r: this.bubbleR * 0.7,
                val: val, type: type,
                vx: (Math.random()-0.5)*1.5, vy: (Math.random()-0.5)*1.5,
                selected: false, scale: 1,
                color: type==='num' ? '#0074D9' : '#FF4136'
            });
        }
    }
    
    ensureBossSolvable() {
        const t = this.mission.targetVal;
        const op = this.mission.targetOp === 'mul' ? 'mul' : 'add';
        this.bubbles.push(this.makeBubble(1, 'num'));
        this.bubbles.push(this.makeBubble(op, 'op'));
        this.bubbles.push(this.makeBubble(t, 'num'));
    }

    makeBubble(val, type) {
        return {
            x: this.width/2 + (Math.random()-0.5)*50,
            y: this.height/2 + (Math.random()-0.5)*50,
            r: this.bubbleR * 0.7, val, type,
            vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2,
            selected: false, scale: 1, color: type==='num' ? '#0074D9' : '#FF4136'
        };
    }

    spawnParticles(x, y, color) {
        for(let i=0; i<8; i++) {
            this.particles.push({ x, y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:1.0, color });
        }
    }
    
    addText(x, y, text, color, size=20) {
        this.texts.push({ x, y, text, color, size, life: 1.0 });
    }

    drawCommander(mood) {
        const ctx = this.commCtx;
        ctx.clearRect(0,0,70,70);
        const x=35, y=35, s=28;
        ctx.fillStyle = mood==='panic'?'#A0A0FF':(mood==='happy'?'#FF4136':'#FFDB58');
        ctx.beginPath(); ctx.arc(x,y,s,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#000'; 
        ctx.beginPath(); ctx.arc(x-8, y-5, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x+8, y-5, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath();
        if(mood==='panic') { ctx.moveTo(x-10,y+10); ctx.lineTo(x+10,y+10); ctx.stroke(); }
        else { ctx.arc(x,y+5,10,0,Math.PI); ctx.fill(); }
    }

    // --- ループ ---
    loop() {
        if (this.state === 'playing') {
            this.timeLeft -= 1/60;
            if (this.timeLeft <= 0) {
                this.state = 'gameover';
                document.getElementById('start-overlay').classList.remove('hidden');
                document.querySelector('.title-text').innerText = "TIME UP";
                document.querySelector('.start-btn').innerText = "RETRY";
            }
            document.getElementById('score-val').innerText = this.score.toString().padStart(5, '0');
            document.getElementById('time-val').innerText = Math.ceil(this.timeLeft);
            const pct = (this.timeLeft/this.maxTime)*100;
            document.getElementById('time-fill').style.width = pct + '%';
        }

        // Draw
        this.ctx.fillStyle = '#020205';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Lasers
        this.ctx.globalCompositeOperation = 'lighter';
        for (let i = this.lasers.length - 1; i >= 0; i--) {
            let l = this.lasers[i];
            l.life -= 0.1;
            this.ctx.strokeStyle = l.color;
            this.ctx.lineWidth = 20 * l.life;
            this.ctx.lineCap = 'round';
            this.ctx.beginPath();
            this.ctx.moveTo(this.width/2, this.height);
            this.ctx.lineTo(l.tx, l.ty);
            this.ctx.stroke();
            this.ctx.lineWidth = 5 * l.life;
            this.ctx.strokeStyle = '#fff';
            this.ctx.stroke();
            if (l.life <= 0) this.lasers.splice(i, 1);
        }
        this.ctx.globalCompositeOperation = 'source-over';

        // Bubbles
        this.bubbles.forEach(b => {
            b.x += b.vx; b.y += b.vy;
            if (b.x < b.r || b.x > this.width-b.r) b.vx *= -1;
            if (b.y < 150 || b.y > this.height-80) b.vy *= -1;
            if (b.scale > 1) b.scale -= 0.05;

            // Background Circle
            this.ctx.fillStyle = b.color;
            this.ctx.beginPath();
            this.ctx.arc(b.x, b.y, b.r * b.scale, 0, Math.PI*2);
            this.ctx.fill();
            
            // Highlight
            this.ctx.fillStyle = 'rgba(255,255,255,0.2)';
            this.ctx.beginPath();
            this.ctx.arc(b.x - b.r*0.2, b.y - b.r*0.2, b.r*0.3, 0, Math.PI*2);
            this.ctx.fill();

            // Lock-on Sight
            if (b.selected) {
                this.drawReticle(b.x, b.y, b.r * 1.3, this.mission.color);
                // リンク線（前のバブルと繋ぐ）
                const idx = this.selectedBubbles.indexOf(b);
                if (idx > 0) {
                    const prev = this.selectedBubbles[idx-1];
                    this.ctx.strokeStyle = this.mission.color;
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath(); this.ctx.moveTo(prev.x, prev.y); this.ctx.lineTo(b.x, b.y); this.ctx.stroke();
                }
            }
            
            // Text (★修正: 白文字 + 影)
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.shadowColor = 'rgba(0,0,0,0.8)';
            this.ctx.shadowBlur = 4;
            this.ctx.font = 'bold 24px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            let label;
            if (b.type === 'num') label = b.val;
            else label = (OPS[b.val] ? OPS[b.val].label : '?');
            this.ctx.fillText(label, b.x, b.y);
            this.ctx.shadowBlur = 0; // Reset
        });

        // Effects
        this.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 4, 0, Math.PI*2); this.ctx.fill();
            this.ctx.globalAlpha = 1;
            if (p.life<=0) this.particles.splice(i,1);
        });

        this.texts.forEach((t, i) => {
            t.y -= 1; t.life -= 0.02;
            this.ctx.globalAlpha = t.life;
            this.ctx.fillStyle = t.color;
            this.ctx.font = `bold ${t.size}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(t.text, t.x, t.y);
            this.ctx.globalAlpha = 1;
            if (t.life<=0) this.texts.splice(i,1);
        });

        requestAnimationFrame(this.loop);
    }

    drawReticle(x, y, r, color) {
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 3;
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, Math.PI*2);
        this.ctx.stroke();
        
        // Rotating Part
        this.ctx.save();
        this.ctx.translate(x, y);
        this.ctx.rotate(Date.now() / 150);
        this.ctx.beginPath();
        this.ctx.arc(0, 0, r * 0.8, 0, Math.PI*1.5);
        this.ctx.stroke();
        this.ctx.restore();
    }
}

window.game = new Game();
</script>
</body>
</html>
